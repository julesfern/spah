---
id: "Spah.DOM.Blueprint"
parent_id: "Spah.DOM"
type: class
superclass_id: "Spah.DOM.Document"
line_number: 29
description: |
  A "blueprint" is a server-side representation of your application's layout. Blueprints are used during Spah's
  cold-rendering cycle, when a user is requesting a page via a regular non-ajax HTTP request. A Blueprint contains
  all the markup for your app, annotated with SpahQL assertions. Whenever the blueprint is served to a user,
  the document logic is run, the document set into precisely the state needed to display the relevant UI state to
  the user and the resulting HTML shipped down the wire to the browser, from whence the Spah client will take over
  for all future requests.
  
  Blueprints are *compiled* from some source HTML, which will be your app's markup with included document logic,
  and after the compile step you may add additional customisations by adding resources such as templates
  and rulesets.
  
  Let's look at an example, with comments:
  
     var blueprint = require('spah').dom.blueprint;
     // Prepare your markup. Read it from the file system, get it from a database, whatever.
     // We want to end up with a String, not a Buffer.
     var html = "<!DOCTYPE HTML><html><head>....</head><body>....</body></html>";
     // Now we'll compile the blueprint
     blueprint.compile(html, function(err, myBlueprint) {
       // Handle errors
       if(err) return console.log("ERROR!", err);
       // Move on with processing
  
     })

file: /home/danski/projects/spah/src/Spah.DOM.Blueprint.js

---
id: "Spah.DOM.Blueprint.compile"
parent_id: "Spah.DOM.Blueprint"
type: class method
line_number: 48
description: |
  (Server-side only) Creates a new HTML5 blueprint document to work with. Parses the file specified in the <code>docPath</code> argument
  into a JSDOM environment, and then reads all Mustache files within the templatePathMask into the blueprint,
  inserting them into script tags at the bottom of the document body.
  
  GOTCHA: If your markup is not valid (for instance, opening a tag that expects to be closed, then never closing it)
  you run the risk of leaving unanswered callbacks from jsdom, which can result in a node process that does not exit
  properly.

signatures:
 -
  signature: "Spah.DOM.Blueprint.compile(htmlPath, templatePathMask, done)"
  return_value: "void"
arguments:
 -
  name: html
  types: [String]
  description: >
    The raw HTML that will form the base of this Blueprint instance.

 -
  name: done
  types: [Function]
  description: >
    The function to call once the document has been compiled. Receives two arguments (error, blueprintInstance).

file: /home/danski/projects/spah/src/Spah.DOM.Blueprint.js

---
id: "Spah.DOM.Blueprint#render"
parent_id: "Spah.DOM.Blueprint"
type: instance method
line_number: 89
description: |
  -> state (Spah.SpahQL): The state object that will be used to render the document's markup
  -> done (Function): A callback function that will receive (err, markup) as arguments, where 'markup' is the full generated markup to be rendered on the client.
  
  Renders markup for the given state

signatures:
 -
  signature: "Spah.DOM.Blueprint#render(state, callback)"
  return_value: "void"
file: /home/danski/projects/spah/src/Spah.DOM.Blueprint.js

---
id: "Spah.DOM.Blueprint#toString"
parent_id: "Spah.DOM.Blueprint"
type: instance method
line_number: 100
description: |
  Returns a string representation of the document's current markup.

signatures:
 -
  signature: "Spah.DOM.Blueprint#toString()"
  return_value: "String"
file: /home/danski/projects/spah/src/Spah.DOM.Blueprint.js