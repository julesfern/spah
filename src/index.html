<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Spah  v0.0.0 API documentation | Home</title>
  <meta name="generator" content="PDoc" />
  
  <script charset="utf-8" src="javascripts/pdoc/prototype.js" type="text/javascript"></script>
  <script charset="utf-8" src="javascripts/pdoc/application.js" type="text/javascript"></script>
<script charset="utf-8" src="javascripts/pdoc/tabs.js" type="text/javascript"></script>
  <script charset="utf-8" src="javascripts/pdoc/item_index.js" type="text/javascript"></script>
  
  <link charset="utf-8" href="stylesheets/pdoc/api.css" media="screen, projection" rel="stylesheet" type="text/css" />
<link charset="utf-8" href="stylesheets/pdoc/pygments.css" media="screen, projection" rel="stylesheet" type="text/css" />
  
  <script type="text/javascript">
    PDoc.pathPrefix = '';
  </script>
</head>
  <body>

    <div id="sidebar">
      <ul id="sidebar_tabs" class="sidebar-tabs">
        <li>
          <a href="#menu_pane">Menu</a>
        </li>
        <li>
          <a href="#search_pane">Search</a>
        </li>
      </ul> <!-- .sidebar-tabs -->

      <form class="search-ribbon">
        <label>
          <span class="hidden">Search</span>
          <input type="text" id="search" size="20" title="Search" />
        </label>
      </form>
      
      <div class="sidebar-pane scrollable" id="menu_pane">
        <ul class="menu-items" id="api_menu"><li><div class="menu-item"><a class="class" href="Spah/index.html" title="Spah (class)">Spah</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/DOM/index.html" title="Spah.DOM (class)">Spah.DOM</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/DOM/Blueprint/index.html" title="Spah.DOM.Blueprint (class)">Spah.DOM.Blueprint</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/DOM/Document/index.html" title="Spah.DOM.Document (class)">Spah.DOM.Document</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/DOM/Errors/index.html" title="Spah.DOM.Errors (class)">Spah.DOM.Errors</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/DOM/Errors/InvalidModifierError/index.html" title="Spah.DOM.Errors.InvalidModifierError (class)">Spah.DOM.Errors.InvalidModifierError</a></div></li></ul></li>
<li><div class="menu-item"><a class="class" href="Spah/DOM/Modifiers/index.html" title="Spah.DOM.Modifiers (class)">Spah.DOM.Modifiers</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/DOM/Modifiers/ClassName/index.html" title="Spah.DOM.Modifiers.ClassName (class)">Spah.DOM.Modifiers.ClassName</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/DOM/Modifiers/ElementId/index.html" title="Spah.DOM.Modifiers.ElementId (class)">Spah.DOM.Modifiers.ElementId</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/DOM/Modifiers/Show/index.html" title="Spah.DOM.Modifiers.Show (class)">Spah.DOM.Modifiers.Show</a></div></li></ul></li></ul></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/index.html" title="Spah.SpahQL (class)">Spah.SpahQL</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/SpahQL/Callbacks/index.html" title="Spah.SpahQL.Callbacks (class)">Spah.SpahQL.Callbacks</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/DataHelper/index.html" title="Spah.SpahQL.DataHelper (class)">Spah.SpahQL.DataHelper</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Errors/index.html" title="Spah.SpahQL.Errors (class)">Spah.SpahQL.Errors</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/SpahQL/Errors/SpahQLError/index.html" title="Spah.SpahQL.Errors.SpahQLError (class)">Spah.SpahQL.Errors.SpahQLError</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Errors/SpahQLRunTimeError/index.html" title="Spah.SpahQL.Errors.SpahQLRunTimeError (class)">Spah.SpahQL.Errors.SpahQLRunTimeError</a></div></li></ul></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Query/index.html" title="Spah.SpahQL.Query (class)">Spah.SpahQL.Query</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/QueryParser/index.html" title="Spah.SpahQL.QueryParser (class)">Spah.SpahQL.QueryParser</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/QueryResult/index.html" title="Spah.SpahQL.QueryResult (class)">Spah.SpahQL.QueryResult</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/QueryResultSet/index.html" title="Spah.SpahQL.QueryResultSet (class)">Spah.SpahQL.QueryResultSet</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/QueryRunner/index.html" title="Spah.SpahQL.QueryRunner (class)">Spah.SpahQL.QueryRunner</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Strategiser/index.html" title="Spah.SpahQL.Strategiser (class)">Spah.SpahQL.Strategiser</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/index.html" title="Spah.SpahQL.Token (class)">Spah.SpahQL.Token</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/Base/index.html" title="Spah.SpahQL.Token.Base (class)">Spah.SpahQL.Token.Base</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/Boolean/index.html" title="Spah.SpahQL.Token.Boolean (class)">Spah.SpahQL.Token.Boolean</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/ComparisonOperator/index.html" title="Spah.SpahQL.Token.ComparisonOperator (class)">Spah.SpahQL.Token.ComparisonOperator</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/FilterQuery/index.html" title="Spah.SpahQL.Token.FilterQuery (class)">Spah.SpahQL.Token.FilterQuery</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/KeyName/index.html" title="Spah.SpahQL.Token.KeyName (class)">Spah.SpahQL.Token.KeyName</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/Numeric/index.html" title="Spah.SpahQL.Token.Numeric (class)">Spah.SpahQL.Token.Numeric</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/PathComponent/index.html" title="Spah.SpahQL.Token.PathComponent (class)">Spah.SpahQL.Token.PathComponent</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/SelectionQuery/index.html" title="Spah.SpahQL.Token.SelectionQuery (class)">Spah.SpahQL.Token.SelectionQuery</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/Set/index.html" title="Spah.SpahQL.Token.Set (class)">Spah.SpahQL.Token.Set</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/Simple/index.html" title="Spah.SpahQL.Token.Simple (class)">Spah.SpahQL.Token.Simple</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/SpahQL/Token/String/index.html" title="Spah.SpahQL.Token.String (class)">Spah.SpahQL.Token.String</a></div></li></ul></li></ul></li>
<li><div class="menu-item"><a class="class" href="Spah/State/index.html" title="Spah.State (class)">Spah.State</a></div><ul><li><div class="menu-item"><a class="class" href="Spah/State/Strategies/index.html" title="Spah.State.Strategies (class)">Spah.State.Strategies</a></div></li></ul></li>
<li><div class="menu-item"><a class="class" href="Spah/StateClient/index.html" title="Spah.StateClient (class)">Spah.StateClient</a></div></li>
<li><div class="menu-item"><a class="class" href="Spah/StateServer/index.html" title="Spah.StateServer (class)">Spah.StateServer</a></div></li></ul></li></ul><!--- #api_menu =-->
      </div> <!-- .sidebar-pane -->
      <div class="sidebar-pane" id="search_pane">
        <ul id="search_results" class="search-results menu-items scrollable"></ul>
      </div> <!-- .sidebar-pane -->
    </div> <!-- #sidebar -->

    <div id="page">
      

      <div id="main" class="page-content">
        

<div class="page-introduction">
  <h1 id='spah_build_awesome_singlepage_apps_without_breaking_the_web'>Spah: Build awesome single-page apps without breaking the web.</h1>

<p><strong>WARNING: EPIC CONSTRUCTION YARD AHEAD. DO NOT BUILD ANYTHING WITH THIS UNTIL THIS MESSAGE DISAPPEARS</strong>.</p>

<h1 id='introduction'>Introduction</h1>

<p>The single-page app paradigm is awesome for creating fancy, stateful web apps that hang right off your service&#8217;s developer API. But in the process of putting entire applications on a single URL, we risk breaking the web. We&#8217;re making our pages unfriendly to search engines and impenetrable to scrapers, microdata clients, and readability engines.</p>

<p>We want to get all the advantages and capabilities of rich single-page javascript apps but <em>without</em> the nasty stuff. That means no hashbangs, no code duplication, and no trickery to give search engines and scrapers what they want.</p>

<p>So here&#8217;s Spah. Spah takes the best from both the single- and multi-page paradigms and boils it down to a few core concepts:</p>

<ol>
<li>A <strong>state</strong> for your UI. That&#8217;s a chunk of JSON that describes which tabs are active, lists of model objects, user preferences, saved form data, that sort of thing.</li>

<li>A <strong>blueprint</strong> for the HTML that makes up your application, much like a template. You define how it will react to changes in the <strong>state</strong> using SpahQL, a powerful query language for JSON.</li>

<li>A <strong>server</strong> that can make changes to the <strong>state</strong>. The server understands your <strong>blueprint</strong> - so if the user enters a URL directly into their browser, the server can apply the <strong>state</strong> to your <strong>blueprint</strong> and deliver proper HTML down the wire. If the user navigates to that URL from within your app, the server can just ship changes to the UI state as plain JSON. The server can update the state selectively, without destroying stuff the user is already doing.</li>

<li>A <strong>client</strong> that adds all the rich single-page behaviours. It keeps the UI synced to changes in the <strong>state</strong>, it manages navigation history and it enables more advanced client-side behaviours such as lazy-loading.</li>
</ol>

<p>Putting these together lets you:</p>

<ul>
<li><strong>Be a good web citizen</strong>. With Spah, every URL in your site may be indexed, bookmarked, shared, syndicated and CURLed.</li>

<li><strong>Progressively enhance, gracefully degrade</strong>. Users with modern browsers get the full rich javascript experience. Users with old browsers get to surf like its 1999. Everyone gets to use your app.</li>

<li><strong>Keep it stateful.</strong> Give proper multitasking by only updating those parts of the UI that need updating. Get vastly reduced server-side code complexity. Everyone wins.</li>

<li><strong>Do all this with <em>zero</em> code duplication.</strong> Spah solves the difficult problems of shared client/server templating and state management, leaving you to work on your app.</li>

<li><strong>Use the tools you like.</strong> Spah is a view layer for your application and nothing more. It doesn&#8217;t care what you use to do your routing, your validations or your persistence.</li>
</ul>

<p>In order to properly explain Spah, lets take a look at a few patterns for building web applications.</p>

<h2 id='anatomy_of_a_simple_web_app'>Anatomy of a simple web app</h2>
<img src='https://img.skitch.com/20110720-mnf4xun1n6gwf461edtp12jmjf.jpg' />
<p>We all recognise this. The server renders pages as they are requested and serves them in the body of a request. As far as the client is concerned, there&#8217;s no difference between your site and one built with static HTML. It has these qualities:</p>

<ul>
<li><em>Good</em>: Every page is indexable and scrapable in every possible state.</li>

<li><em>Good</em>: Since the state of the page is handled exclusively by the server, state can be maintained as the user navigates between pages.</li>

<li><em>Bad</em>: Since the state of the page is handled exclusively by the server, maintaining state requires the developer to wrangle highly complicated query strings.</li>

<li><em>Bad</em>: Since every user action requires a full page load, a lot of user experience goodness goes out the window and good performance is hard to achieve.</li>
</ul>

<h2 id='anatomy_of_a_singlepage_web_app'>Anatomy of a single-page web app</h2>
<img src='https://img.skitch.com/20110504-73a3ftde7d731kbepxg2p7w1.jpg' />
<p>This is pretty much where we are today. You get the much-desired &#8220;desktop&#8221; class of application, and you do it by writing the UI entirely in javascript with little to no markup handled on the server. You pull data in from your app&#8217;s API in JSON format. But we&#8217;ve made some serious concessions:</p>

<ul>
<li><em>Good</em>: The whole UI runs within a single page, so you can have multiple complex stateful UI elements that retain their state as the rest of the page is updated.</li>

<li><em>Good</em>: The whole UI runs within the browser, so you&#8217;ve got templating handled in the client. No duplication of template code.</li>

<li><em>Bad</em>: It needs a browser to run. You can&#8217;t deliver markup for non-browser requests without creating an HTML rendering chain on the server.</li>

<li><em>Bad</em>: We&#8217;re not indexable any more. Your app only has one URL, and it serves content-free boilerplate markup. If you decide to make your URLs server-renderable, then you&#8217;re going to need multiple rendering chains and a lot of code duplication.</li>

<li><em>Bad</em>: Perceptual performance suffers, but not because of server inefficiencies such as those seen in the simple web app model. Instead, we introduce multiple HTTP turnarounds to start the app - one to load the page, several more to populate it with content.</li>
</ul>

<h2 id='anatomy_of_a_spah_web_app'>Anatomy of a Spah web app</h2>

<p>With Spah, we take a little of the basic multi-page paradigm&#8230;</p>
<img src='https://img.skitch.com/20110504-p13hfga9s4d6x7bpjwrw1gbyjj.jpg' title='A cold render' />
<p>And we rejig it to allow any page to boot into stateful single-page mode, giving us all the advantages of the new model:</p>
<img src='https://img.skitch.com/20110504-tpqb613eyy46j7f758nqr745n2.jpg' title='A warm render' />
<p>Once the page has loaded, all the rich client behaviours kick in - any further action taken by the user will result in the state of the current page being updated. The Spah Client manages history using the HTML5 History API, allowing the user to move freely around your app and making every link share, bookmark and script-friendly. If the user needs to do something synchronously - say, a file upload, or a secure login - Spah can pass the state to the server where it gets modified, and handed back as another plain HTML document.</p>

<h1 id='core_concepts'>Core Concepts</h1>

<h2 id='the_state'>The State</h2>

<p>Spah&#8217;s central concept is the State. The State is a JSON object that describes the configuration of your application&#8217;s user interface. That&#8217;d be things like user preferences, active tabs, saved form data, or lists of model objects. Here&#8217;s a dead simple example for a basic Twitter UI:</p>

<pre><code>{
	&quot;user&quot;: {
		&quot;logged_in&quot;: true,
		&quot;name&quot;: &quot;John Doe&quot;,
		&quot;email&quot;: &quot;john@doe.com&quot;,
		&quot;handle&quot;: &quot;johndoe&quot;,
		&quot;avatar&quot;: {
			&quot;small&quot;: &quot;https://myapp.com/avatar-small/goatse.png&quot;,
			&quot;large&quot;: &quot;https://myapp.com/avatar-large/goatse.png&quot;
		}
	},
	&quot;active_tab&quot;: &quot;timeline&quot;,
	&quot;draft_status&quot;: &quot;I&#39;m not sure I should post this&quot;,
	&quot;timeline&quot;: [
		{
			&quot;type&quot;: &quot;status&quot;,
			&quot;status&quot;: &quot;FFFFFFFUUUUUUUUUUUU&quot;,
			&quot;user&quot;: {
				&quot;name&quot;: &quot;Rage Guy&quot;,
				&quot;handle&quot;: &quot;rageguy&quot;,
				&quot;avatar&quot;: {
					&quot;small&quot;: &quot;https://myapp.com/avatar-small/f7u12.png&quot;,
					&quot;large&quot;: &quot;https://myapp.com/avatar-large/f7u12.png&quot;
				}
			}
		},
		...
	],
	&quot;mentions&quot;: null
	&quot;direct_messages&quot;: null
}</code></pre>

<p>In this state we&#8217;ve got the user&#8217;s profile available to us for display, we know that the &#8220;timeline&#8221; tab is open and populated with some tweets, and we know that the user hasn&#8217;t loaded any mentions or direct messages just yet. We also know that the user has typed something into the status field but has not yet saved it.</p>

<p>The State&#8217;s schema is unique to your application - Spah just gives you the tools for manipulating it.</p>

<h2 id='spah_query_language'>Spah Query Language</h2>

<p><a href='#spahql'>SpahQL</a> is a simple query language for Javascript objects. You can use it to query JSON data:</p>

<pre><code>var data = the_twitter_example_from_above;
var state = new Spah.State(data);

state.select(&quot;/user/name&quot;) // get the user&#39;s real name
state.select(&quot;//user/name&quot;) // get the name of all users, everywhere in the state
state.select(&quot;//[/type==&#39;status&#39;]&quot;) // get everything with type=status
state.select(&quot;//mentions/[/type==&#39;status&#39;]/user/handle&quot;) // get every handle for every tweet in the mentions list</code></pre>

<p>To modify data, using SpahQL&#8217;s simple editing APIs:</p>

<pre><code>state.select(&quot;/user&quot;).set(&quot;name&quot;, &quot;Captain Hammer&quot;); // Change the user&#39;s name
state.select(&quot;/user/name&quot;).replace(&quot;Dr. Horrible&quot;); // Another way to edit values
state.select(&quot;//user/name&quot;).replaceAll(&quot;Spartacus&quot;); // Rename everyone
state.select(&quot;//user/name&quot;).deleteAll(); // Anonymise everyone</code></pre>

<p>And to make assertions about data:</p>

<pre><code>state.assert(&quot;/user/name&quot;) // does &#39;name&#39; exist on &#39;/user&#39;?
state.assert(&quot;//mentions/.length &gt; 2&quot;) // more than 2 mentions loaded?
state.assert(&quot;//*[/.type==&#39;array&#39;]/.length &gt; 0&quot;) // any non-empty arrays anywhere in the state?</code></pre>

<p>As the name suggests, <a href='#spahql'>SpahQL</a> is built right in to Spah and is used for the majority of your work with the State.</p>

<p>SpahQL is primarily used to describe how any given <em>state</em> is applied to your <a href='#html_blueprints'>HTML Blueprint</a> - for instance:</p>

<pre><code>&lt;nav class=&quot;account&quot; data-show-if=&quot;/user_authenticated&quot;&gt;
	&lt;!-- This element only shown if user logged in. --&gt;
&lt;/nav&gt;</code></pre>

<h2 id='cold_requests'>Cold requests</h2>

<p><em>Cold</em> requests are synchronous HTTP requests made to your app - maybe the user was sent to yourapp.com/foo/bar by a search engine or social link. Maybe they used a bookmark, or maybe they just made a multipart POST. Regardless, the client is expecting a response containing useful HTML.</p>

<p>Both the Spah Server and the Spah Client understand how to apply any given <em>state</em> to your app&#8217;s <a href='#html_blueprints'>HTML Blueprint</a> - this means that the Spah Server is able to respond to <em>cold</em> requests with a properly-populated HTML document.</p>

<p>Once the HTML has been returned to the user agent, in-page Javascript (including the Spah Client) can kick in and <em>progressively enhance</em> the pre-existing content with fancy client-side interactivity.</p>

<h2 id='warm_requests'>Warm requests</h2>

<p>Typically, <em>warm</em> requests follow cold. Once the user agent has made a cold request and received the HTML for your app, the Spah Client is initialised to handle your app&#8217;s navigation.</p>

<p>Any internal links (or forms that submit to internal URIs) have their default actions intercepted and replaced with an asynchronous request to the Spah Server, which is expected to respond with JSON representing an updated <em>state</em>.</p>

<p>From there, the Spah Client can accept the updated state and make any necessary DOM modifications in-place.</p>

<h1 id='the_spah_server'>The Spah Server</h1>

<p>The Spah Server is a Node.js library intended to deliver state updates to users over the wire. Spah doesn&#8217;t include an HTTP server - you&#8217;re free to pick your application framework.</p>

<p>The Spah Server is a view layer for your application. As discussed in <a href='#core_concepts'>Core Concepts</a>, Spah seperates view handling into two steps - state modification and blueprint rendering. Each of these may be performed on either the client or the server. <em>Warm</em> requests require only that the state be modified and sent to the client as JSON, while <em>cold</em> requests require that the state be modified and rendered as <a href='#html_blueprints'>HTML</a>.</p>

<p>In a sense, Spah allows your server-side app to <em>behave like a browser</em> and boot your client-side application to the point of usefulness, before letting the client browser carry out the rest of the startup process. This is achieved by moving template logic to a place where <a href='#html_blueprints'>both the client and the server can use it</a>.</p>

<h2 id='install_the_server'>Install the server</h2>

<pre><code>npm install spah</code></pre>

<h2 id='boot_the_server'>Boot the server</h2>

<p>A Spah Server is simple enough to initialise. Start out with some HTML. Put it on your file system, in mongo, wherever you like.</p>

<pre><code>// If you use readFileSync during a request cycle,
// you will be haunted by a pigeon. During app startup
// is fine.
var html = require(&#39;fs&#39;).readFileSync(&quot;blueprint.html&quot;, &quot;utf-8&quot;);</code></pre>

<p>Now you just create a Spah Server:</p>

<pre><code>var spah = require(&#39;spah&#39;);
// Lets specify a default state
var stateDefaults = {
	&quot;active_tab&quot;: &quot;timeline&quot;
};
// Create a new StateServer instance
var stateServer = spah.createServer();</code></pre>

<h2 id='configure_the_server'>Configure the server</h2>

<p>Spah doesn&#8217;t know which HTTP stack you&#8217;re using, so by extension it doesn&#8217;t know how to work with your choice of HTTP Request and HTTP Response objects.</p>

<p>Spah only needs to know a few basic interactions, so we&#8217;ll configure it here:</p>

<pre><code>// Tell the server how to get the current UI state
// from an inbound request. This will vary depending
// on your choice of HTTP stack.
// 
// If this function returns a string, Spah will parse
// it as JSON before doing anything with it. If it
// returns an object, we&#39;ll use it as-is.
//
// The Spah Client defaults to attaching the current UI
// state to the query string, but you can customise that
// using client.attachStateToRequest. See the API docs
// for examples.
var stateServer.identifyStateFromRequest(function(request) {
	return request.param(&quot;spah_state&quot;, &quot;{}&quot;);
});

// Tell the server how to tell if a request is warm
// or not. 
// 
// Much like getStateFromRequest (above), the method
// used to mark a request as &quot;warm&quot; - that is,
// as coming from an initialised Spah Client and not 
// requiring a full HTML render - can be customised
// on the Spah Client. The default is to use a custom
// Accept header to indicate the client&#39;s preferred format.
var stateServer.identifyWarmRequest(function(request) {
	return request.header(&quot;Accept&quot;) == &quot;application/state+json&quot;;
});</code></pre>

<p>The final step is to load an <a href='#html_blueprints'>HTML Blueprint</a> for Spah to work with when rendering HTML:</p>

<pre><code>// Remember, using fs.readFileSync during a request will
// lead to you being haunted by a pigeon. During app boot
// is fine.
var html = require(&#39;fs&#39;).readFileSync(&quot;/path/to/layout.html&quot;, &quot;utf-8&quot;);
stateServer.compileBlueprint(html, startServerWithBlueprint);</code></pre>

<p>We haven&#8217;t defined <code>startServerWithBlueprint</code> yet, but it&#8217;s going to be used to kick off the app itself in the next example.</p>

<h2 id='responding_to_user_requests'>Responding to user requests</h2>

<p>I&#8217;ll assume Express is being used for this example, purely for sanity&#8217;s sake. Let&#8217;s take a look at building an action:</p>

<pre><code>// This is the callback for our blueprint example above.
// it takes an error and the Spah.DOM.Blueprint instance
// you just created.
function startServerWithBlueprint(err, blueprint) {
	if(err) throw err;	
	
	// Got a blueprint, got a spah server.
	// Good to go.

	var express = require(&#39;express&#39;);
	var params = require(&#39;express-params&#39;);
	var app = express.createServer();
	params.extend(app);
	
	app.get(&quot;/&quot;, function(request, response, next) {
		
		// This is the homepage, so it re-applies the
		// defaults without changing other stuff.
		var state = stateServer.stateWith(
			// Pull the state from the params
			// the state server will parse this as JSON
			// if you hand it a string
			request.param(&quot;state&quot;, &quot;{}&quot;),
			// Apply the defaults to the user state,
			// restoring the app to the &quot;home&quot; state
			stateDefaults
		);
		
		var warm = request.param(&quot;state&quot;, null);
		stateServer.render(warm, state, function(err, contentType, content) {
			// &quot;content&quot; might be JSON or HTML
			if(err) throw err;
			response.header(&#39;Content-Type&#39;, contentType);
			response.send(content);
		});
	});
	
	// Open the floodgates
	app.listen(80);

}</code></pre>

<h2 id='the_state_expander'>The State Expander</h2>

<p>We want populating the state to be <em>clean</em> - you shouldn&#8217;t have to account for everything required by your UI in each response from your server - and most parts of the state simply won&#8217;t be relevant unless you&#8217;re responding to a <em>cold</em> request. For instance, rendering a page showing Twitter mentions for the user would require only that the state be populated with tweets for <em>warm</em> requests, but <em>cold</em> requests would require that the page be populated with other information - the user&#8217;s follower count, for example.</p>

<p>The Spah Server solves the problem of overcomplicated controller code by providing <em>state expanders</em>, which are macros used to flesh out the state and populate it with data in the event that a full HTML render is required. The State Expander also allows you to enforce security rules by only populating the state with objects according by your app&#8217;s security model.</p>

<p>Let&#8217;s look at an example. We want to populate the state with some information about the user&#8217;s Twitter profile when rendering HTML responses.</p>

<pre><code>stateServer.addExpander(
	{&quot;path&quot;: &quot;/followers/count&quot;, &quot;if&quot;: &quot;/user_authenticated&quot;},
	function(results, state, request, expander) {
		twitterUser.fetchFollowerCount(function(count) {
			console.log(&quot;setting &quot;+queryResult.path+&quot; to &quot;+ count);
			results.replace(count);
			expander.done();
		}
	}
);</code></pre>

<p>The example above checks that the <a href='#assertion_queries'>SpahQL assertion</a> <code>/user\_authenticated</code> returns <code>true</code>, and if so, selects <code>/followers/count</code> from the state and runs the callback function against the returned result. If no &#8220;if&#8221; or &#8220;unless&#8221; condition is specified, the expander will run unconditionally. Note that both <em>paths</em> and <em>if</em>/_unless_ are scoped to the root of your state. If you specify multiple paths, you are effectively registering multiple expanders each with the same condition and callback - the expander will execute against one path query at a time.</p>

<p>The callback receives as its arguments <em>results</em>, a SpahQL QueryResultSet instance containing all matches for the specified path, <em>state</em>, the state object being queried, the <em>request</em> object, and the <em>expander</em> object which itself will contain a function <code>done(value)</code>. In our callback example, we overwrite the value of <code>/followers/count</code> with some abitrary value and then call the <code>done</code> function to signal that the expander has finished fetching data, and that the next expander may be run. Expanders are run in serial fashion for data integrity reasons.</p>

<p>State Expanders are applied in the order in which they were registered via <code>addExpander</code>. Multiple expanders may be run on the same path. You may set expanders for multiple paths by using <code>{paths: [path1, path2, pathN], "if": "/condition"}</code>. If any given path returns more than one <code>QueryResult</code>, the results of the expander will be applied to all matching paths.</p>

<h1 id='the_spah_client'>The Spah Client</h1>

<p>TODO: In environments that support JS, the state in forms and links is replaced with the current state on submission/activation.</p>

<p>The Spah client handles things at the browser end. Its primary tasks are:</p>

<ol>
<li>Ensuring that links and forms are submitted asynchronously and that they attach the state when activated (you may also <a href='#forcing_links_and_forms_to_load_synchronously'>prevent some links and forms from acting asynchronously</a>)</li>

<li>Ensuring that async requests are submitted with a <code>content-accept</code> header of <code>application/state+json</code>, allowing the server-side application to determine that this is a warm request and should be responded to with an updated state</li>

<li>Re-evaluating and processing any document logic whenever the state is modified</li>

<li>Raising path-specific events whenever the state is modified</li>
</ol>

<p>This is achieved by embedding template logic within the markup using HTML5 data attributes, thus making the same template logic available to both client and server. When the state is updated by a response from the server, elements with embedded display logic are re-evaluated automatically and the display updated accordingly.</p>

<p>You may also bind more advanced behaviours to changes in the state using <a href='#responding_to_state_changes_with_javascript'>jQuery responders</a> and <a href='#spahql'>state queries</a></p>

<h2 id='install_the_client'>Install the client</h2>

<h2 id='initialise_the_client'>Initialise the client</h2>

<p>For cleanliness, Spah keeps all of its functions, classes and behaviour within the top level <code>Spah</code> object. Initialising Spah is simple:</p>

<h2 id='configure_the_client'>Configure the client</h2>

<h2 id='the_state_reducer'>The State Reducer</h2>

<p>Whenever the Spah Client intercepts a navigation action, such as submitting a form or following a link, the current <em>state</em> is attached to the request so that the server is able to make decisions. If your state contains model objects, this could get pretty large. Spah provides <em>state reducers</em>, macros which once registered are run against the state and remove unnecessary information before the state is sent to the server. The State Reducer uses the same basic <a href='#spahql_strategies'>SpahQL Strategies</a> mechanism as the <a href='#the_state_expander'>State Expander</a> on the server side.</p>

<pre><code>// Remove the contents of the &quot;mentions&quot; tree if it contains anything
stateClient.addReducer(
	{&quot;path&quot;: &quot;/mentions&quot;, &quot;if&quot;: &quot;/mentions/.length &gt; 0&quot;}, 
	function(mentions, root, attachments, strategy) {
			mentions.deleteAll();
			strategy.done();
	};
);</code></pre>

<p>Spah provides some convience strategies for the most common reducer use cases - removing a list of keys from a set of paths, and removing everything <em>except</em> a list of keys from a set of paths.</p>

<p>Here&#8217;s some examples:</p>

<pre><code>// Remove everything from /mentions and /timeline
// except &quot;id&quot; keys, keeping the order and structure intact.
stateClient.addReducer(
	{&quot;paths&quot;: [&quot;/mentions&quot;, &quot;/timeline&quot;]}, 
	Spah.State.Strategies.keeper(&quot;//id&quot;)
);
// Remove everything from /mentions without deleting 
// /mentions altogether
stateClient.addReducer(
	{&quot;path&quot;: &quot;/mentions&quot;}, 
	Spah.State.Strategies.remover(&quot;/*&quot;)
);
// Reduce a model, wherever it appears, to include only 
// type and id
stateClient.addReducer(
	{&quot;path&quot;: &quot;//[/type==&#39;myModel&#39;]&quot;}, 
	Spah.State.Strategies.keeper(&quot;/id&quot;, &quot;/type&quot;)
);</code></pre>

<h2 id='responding_to_state_changes_with_javascript'>Responding to state changes with Javascript</h2>

<h2 id='forcing_links_and_forms_to_load_synchronously'>Forcing links and forms to load synchronously</h2>

<p>To prevent Spah from adding asynchronous behaviour, add the <code>data-async="false"</code> attribute to the link or form element:</p>

<h2 id='eager_client_state_changes'>Eager client state changes</h2>

<h1 id='spahql'>SpahQL</h1>

<h2 id='spahql_core_concepts'>SpahQL Core concepts</h2>

<p>SpahQL is an execution-safe query language designed to let you ask complex questions of basic JSON constructs. SpahQL is designed to work against your application&#8217;s state, but it will work happily against any combination of native hashes, arrays, strings, booleans and numbers.</p>

<p>SpahQL allows two kinds of query: <strong><a href='#selection_queries'>Selection queries</a></strong> are those which retrieve a set of results from your object, while <strong><a href='#assertion_queries'>Assertion queries</a></strong> are those that return a boolean result.</p>

<p>SpahQL is biased towards value equality over key equality. It is assumed that the keys in your object are known, curated namespace with arbitrary values. For this reason SpahQL&#8217;s matching is designed to focus on comparing values, not keys.</p>

<p>All SpahQL queries are read-only; there is no semantic for updating the state.</p>

<p>Furthermore, SpahQL uses set arithmetic for comparisons. Rather than providing an imperative syntax with complex logic, SpahQL provides set operations that allow you to build the equivalent of the <code>AND</code> and <code>OR</code> operations from other query languages using a safe, declarative syntax.</p>

<h2 id='selection_queries'>Selection queries</h2>

<p>To select items from the state, use the basic syntax:</p>

<p>The basic constituent of a selection query is a <em>path selector</em>. With an example object:</p>

<p>It&#8217;s easy to make selections based on a known path. To pull up the contents of the key &#8220;myHash&#8221; in the root, use the following syntax and remember that <strong>paths always begin with a slash</strong>.</p>

<p>Or to pull up the contents of the subhash:</p>

<p>Recursion is supported with a double-slash anywhere in the path:</p>

<p>The results are always returned as a set of <code>Spah.SpahQL.QueryResult</code> objects, which each have properties <code>path</code> and <code>value</code>:</p>

<p>Keys in arrays are treated just like keys in hashes:</p>

<p>You may also use <code>*</code> as a wildcard in paths:</p>

<p>Path queries are <strong>reductive</strong>. When executed, the first part of the query is run against the top level of the object being queried, and the remaining results are handed to the next part of the path to be reduced further. This loop continues until we&#8217;re either out of results or out of path segments.</p>

<p>Using these reductive characteristics, we can perform advanced queries with <strong>filter queries</strong>. Filter queries are contained in square brackets, and can be used to further reduce the results before the query runner moves on to the next path segment.</p>

<p>There are a few things to note about the query inside the <code>[]</code> brackets. Firstly, it has access to the full query syntax. Secondly, it runs within the scope of the current path segment. Take this query for example:</p>

<p>If you want to lookup data on the root from inside a filter query, use the <code>$</code> symbol to force a path to execute on the root context:</p>

<p>I&#8217;m sure by now that you&#8217;ve noticed the filter queries contain <strong>comparison operators</strong>. Any query containing a comparison operator is automatically executed as an <a href='#assertion_queries'>assertion query</a>:</p>

<ul>
<li>
<p>A <strong>selection</strong> query:</p>

<pre><code>  /myHash</code></pre>
</li>

<li>
<p>An <strong>assertion</strong> query:</p>

<pre><code>  /myHash == /someOtherHash</code></pre>
</li>

<li>
<p>A <strong>selection</strong> query containing an assertion query as a filter:</p>

<pre><code>  /myHash[/foo == &#39;baz&#39;]</code></pre>
</li>

<li>
<p>An <strong>assertion</strong> query containing two selection queries, one of which contains an assertion query as a filter:</p>

<pre><code>  /myHash[/foo == &#39;baz&#39;] == /myArr</code></pre>
</li>
</ul>

<h2 id='assertion_queries'>Assertion queries</h2>

<p>We&#8217;ve already seen how assertion queries can be used as filters in <a href='#selection_queries'>selection queries</a>. Assertion queries are also used heavily in Spah&#8217;s <a href='#html_blueprints'>document logic</a> features.</p>

<p>Assertion queries are run through the <code>assert</code> method on the state:</p>

<p>The <code>assert</code> method accepts both selection and assertion queries - if the given query is a selection query, the result will be <code>true</code> if the query returns one or more results with non-false (i.e. not false or null) values.</p>

<p>As discussed in <a href='#spahql_core_concepts'>core concepts</a>, all comparisons in SpahQL use set arithmetic instead of traditional imperative logic and equality. SpahQL comparisons allow you to determine if:</p>

<ul>
<li>One set is exactly equal to another set</li>

<li>One set contains the same values as another set</li>

<li>One set is a subset of another set</li>

<li>One set is a superset of another set</li>
</ul>

<h2 id='assertion_queries_literals_and_sets'>Assertion queries: Literals and sets</h2>

<p>SpahQL does support literals - strings, integers, floats, <code>true</code>, <code>false</code> and <code>null</code> may all be used directly in SpahQL queries:</p>

<p>All comparisons in SpahQL are <strong>set comparisons</strong>. A query like <code>/foo</code> returns a set of results. A literal like <code>3</code> or <code>"somestring"</code> is considered to be a set containing a single entity. Literals may be wrapped in <code>{}</code> mustaches and seperated with commas to create in-place sets:</p>

<p>Sets may also be built from a combination of literals and queries:</p>

<p>You may also create ranges:</p>

<h2 id='comparison_operators'>Comparison operators</h2>

<p>SpahQL&#8217;s set arithmetic uses simple operators:</p>

<ul>
<li>
<p>Set equality <code>==</code></p>

<p>Asserts that both the left-hand and right-hand sets have a 1:1 relationship between their values. The values may come from different paths in the state, or be literals. The values do not have to be in the same order. Each value has its equality checked based on its type. See <a href='#object_equality'>Object equality</a>.</p>
</li>

<li>
<p>Set inequality <code>!=</code></p>

<p>Asserts that the sets are not identical under the rules of the <code>==</code> operator.</p>
</li>

<li>
<p>Subset of <code>}&lt;{</code></p>

<p>Asserts that the left-hand set is a subset of the right-hand set. All values present in the left-hand set must have a matching counterpart in the right-hand set.</p>
</li>

<li>
<p>Superset of <code>}&gt;{</code></p>

<p>Asserts that the left-hand set is a superset of the right-hand set. All values present in the right-hand set must have a matching counterpart in the left-hand set.</p>
</li>

<li>
<p>Joint set <code>}~{</code></p>

<p>Asserts that the left-hand set contains one or more values that are also present in the right-hand set.</p>
</li>

<li>
<p>Disjoint set <code>}!{</code></p>

<p>Asserts that the left-hand set contains no values that are also present in the right-hand set.</p>
</li>

<li>
<p>Rough equality <code>=~</code></p>

<p>Asserts that one or more values from the left-hand set are roughly equal to one or more values from the right-hand set. See <a href='#object_equality'>Object equality</a>.</p>
</li>

<li>
<p>Greater than (or equal to) <code>&gt;=</code> and <code>&gt;</code></p>

<p>Asserts that one or more values from the left-hand set is greater than (or equal to) one or more values from the right-hand set.</p>
</li>

<li>
<p>Less than (or equal to) <code>&lt;=</code> and <code>&lt;</code></p>

<p>Asserts that one or more values from the left-hand set is less than (or equal to) one or more values from the right-hand set.</p>
</li>
</ul>

<h2 id='object_equality'>Object equality</h2>

<p>The equality of objects is calculated based on their type. Firstly, for two objects to be equal under strict equality (<code>==</code>) they must have the same base type.</p>

<ul>
<li><strong>Object equality</strong>: The objects being compared must contain the same set of keys, and the value of each key must be the same in each object. If the value is an object or an array, it will be evaluated recursively.</li>

<li><strong>Array equality</strong>: The arrays must each contain the same values in the same order. If any value is an array or object, it will be evaluated recursively.</li>

<li><strong>Number, String, Bool, null</strong>: The objects must be of equal type and value.</li>
</ul>

<p>Under rough equality (<code>=~</code>) the rules are altered:</p>

<ul>
<li><strong>Strings</strong> are evaluated to determine if the left-hand value matches the right-hand value, evaluating the right-hand value as a regular expression e.g. <code>"bar" =~ "^b"</code> returns <code>true</code> but <code>"bar" =~ "^a"</code> returns <code>false</code></li>

<li><strong>Numbers</strong> are evaluated with integer accuracy only (using Math.floor, numeric.floor or an equivalent operation)</li>

<li><strong>Arrays</strong> behave as if compared with the joint set operator.</li>

<li><strong>Objects</strong> are roughly equal if both hashes contain one or more keys with the same corresponding values. Values are compared using strict equality.</li>

<li><strong>Booleans and null</strong> are evaluated based on truthiness rather than exact equality. <code>false =~ null</code> is <code>true</code> but <code>true =~ false</code> is <code>false</code>.</li>
</ul>

<p>N.B: Objects that are of different types are never roughly equal.</p>

<p>When using inequality operators <code>&lt;</code>, <code>=&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>:</p>

<ul>
<li><strong>Strings</strong> are evaluated based on alphanumeric sorting. <code>"a" &lt;= "b"</code> returns <code>true</code> but <code>"z" &gt;= "a"</code> returns <code>false</code>.</li>

<li><strong>Numbers</strong> are evaluated, as you&#8217;d expect, based on their native values.</li>

<li><strong>Arrays, Objects, Booleans, null</strong> are not compatible with these operators and will automatically result in <code>false</code> being returned.</li>
</ul>

<h2 id='properties'>Properties</h2>

<p>Properties are like imaginary paths on objects in your state. Each property uses the <code>.propertyName</code> syntax and may be used in any path query:</p>

<ul>
<li>
<p><strong>.type</strong> Returns the object type as &#8216;Object&#8217;, &#8216;Array&#8217;, &#8216;String&#8217;, &#8216;Number&#8217;, &#8216;Boolean&#8217; or &#8216;null&#8217;</p>
</li>

<li>
<p><strong>.size</strong> Returns the object&#8217;s size if it is a String (number of characters), Array (number of items) or Object (number of keys)</p>

<pre><code>  // Number of keys in the root
  results = Spah.state.select(&quot;/.size&quot;);
  results[0].path //-&gt; &quot;/.size&quot;
  results[0].value //-&gt; 3
  
  // Find all strings longer than 3 characters
  results = Spah.state.select(&quot;//[/.type == &#39;String&#39;][/.size &gt; 3]&quot;)
  results[0].path //-&gt; &quot;/myHash/mySubHash/bar&quot;</code></pre>
</li>

<li>
<p><strong>.explode</strong> Returns the object broken into a set that may be compared to other sets. Strings are exploded into a set of characters. Arrays and objects do not support this property - use the wildcard (*) character instead.</p>
</li>
</ul>

<h2 id='spahql_strategies'>SpahQL Strategies</h2>

<p><em>Strategies</em> are a mechanism provided by SpahQL allowing you to define a queue of asynchronous actions to be run in order against a QueryResult object, provided that the value of the query result matches the criteria you specify. Strategies are managed using the <code>Strategiser</code> class:</p>

<pre><code>	var state = new Spah.State({a: {aa: &quot;a.aa.val&quot;, bb: &quot;a.bb.val&quot;}, b: {bb: &quot;b.bb.val&quot;, cc: &quot;b.cc.val&quot;}});
	var strategiser = new Spah.SpahQL.Strategiser();</code></pre>

<p>Strategies are objects which define a set of target paths, a condition which must be met for the strategy to run, and an action to take against the matched paths:</p>

<pre><code>	// Add a strategy to the strategiser...
	strategiser.addStrategy(
		// which will take action on /aa and /b/cc, but only if the assertion &quot;/b/bb&quot; returns true
		{&quot;paths&quot;: [&quot;/aa&quot;, &quot;/b/cc&quot;], &quot;if&quot;: &quot;/b/bb&quot;}, 
		// with a named category
		&quot;reduce&quot;,
		// when triggered, the strategy will be called
		function(results, root, attachments, strategy) {
				// make changes to the matched results
				results.deleteAll();
				// signal that the strategiser can advance to the next strategy in the queue
				strategy.done();
		}
	);</code></pre>

<p>Strategies must specify the key <em>path</em> or <em>paths</em>, a path or array of paths for the strategy to modify. Strategies may optionally use the key <em>if</em> or <em>unless</em>, containing a SpahQL assertion whose expectation must be met for this strategy to be included. When we execute the strategies against a target QueryResult, <em>path</em>, <em>paths</em>, <em>if</em> and/or <em>unless</em> will be evaluated relative to the target QueryResult.</p>

<p>Strategies also specify an <em>action</em>, a function containing the strategy&#8217;s behaviour. It receives the arguments <em>results</em>, a QueryResultSet containing matches for the <em>path</em>, <em>root</em>, the original target QueryResult, <em>attachments</em>, an arbitrary object you may pass in when you execute the strategies, and <em>strategy</em>, an object containing flow control functions allowing you to signal that the strategy has completed.</p>

<p>Specifying multiple paths using the <em>paths</em> key is equivalent to registering multiple strategies each with the same expectation and action - the action function will be called once for each query specified in the <em>paths</em> array and calling <code>strategy.done()</code> will advance the queue to the next path in this strategy, or to the next strategy.</p>

<p>Execution is as follows:</p>

<pre><code>	strategiser.run(target, category, attachments, callback);</code></pre>

<p>When applied to the above example:</p>

<pre><code>	// Clone the State first to run the strategies without modifying the original
	// Run the strategies in the &quot;reduce&quot; category
	// Pass {foo: &quot;bar&quot;} as an attachment that will be available to all the strategies
	// Pass a callback function which will receive the modified QueryResult and the attachments
	strategiser.run(state.clone(), &quot;reduce&quot;, {foo: &quot;bar&quot;}, function(clone, attachments) {
			console.log(clone.select(&quot;/aa&quot;).length()); //-&gt; 0, as the above strategy deleted this value
	});</code></pre>

<h1 id='html_blueprints'>HTML Blueprints</h1>

<p>In a Spah application, document logic (show this, hide that, populate this with that) is moved away from in-place Erb views and into a place where both the client and the server will have access to it - the document itself. In doing this, we want to avoid doing anything silly like adding new tags or attributes that break HTML validity, or dirtying up your markup with billions of extra nested div elements.</p>

<p>Spah handles document logic with HTML5 data attributes. Elements may query the state and declare how they should be altered when the query result is returned. When cold-booting your application from the server, the document logic is evaluated and run in-place before sending the HTML down the wire - this is what allows Spah to respond to HTML requests with valid, useful documents. On the client side, updates to the state cause any embedded document logic to be re-evaluated automatically. All document logic is achieved using <a href='#spahql'>State Queries</a>. Conditions such as <code>if</code> statements use truthiness queries, as seen in the <a href='#assertion_queries'>state query documentation</a>.</p>

<p>Spah provides the following operations on document logic:</p>

<h2 id='hide_or_show_an_element'>Hide or show an element</h2>

<p>Show/hide of an element is achieved by appending <code>display: none;</code> to the element&#8217;s <code>style</code> attribute if it should be hidden.</p>

<h2 id='add_or_remove_element_classes'>Add or remove element classes</h2>

<p>Use the <code>data-class-[classname]-if</code> or <code>-unless</code> attribute to specify that a specific class should be appended to the element&#8217;s <code>class</code> attribute.</p>

<pre><code>&lt;li class=&quot;item&quot; data-class-current-if=&quot;/items[0]/important&quot;&gt;
  This list item will have the class &quot;important&quot; if the first item in the 
  array at &quot;/items&quot; has the &quot;important&quot; property
&lt;/li&gt;</code></pre>

<h2 id='set_element_id'>Set element ID</h2>

<p>Use the <code>data-id-[id]-if</code> or <code>-unless</code> to specify that an element should be given a new <code>id</code> under certain circumstances. If the condition causes Spah to write the ID on an element, Spah will automatically remove the ID from any other elements that previously possessed it.</p>

<h2 id='stash_and_unstash_element_content'>Stash and unstash element content</h2>

<p>Stashing content allows you to render semantically-null empty elements into your document, with their content stowed in a data attribute for later use. Stashing only occurs if there is no content already stashed on the element - thus stashed content may be used for state-toggling. See <a href='#advanced_document_logic_example'>example</a>.</p>

<h2 id='populate_element_from_a_template'>Populate element from a template</h2>

<p>Spah can use shared Mustache templates to render state data into a containing element. The Populate modifier is added to your Blueprint by default and adds two methods for managing templates:</p>

<pre><code>myBlueprint.addTemplate(&quot;users/listItem&quot;, templateString, &quot;text/mustache&quot;);
myBlueprint.removeTemplate(&quot;users/listItem&quot;);</code></pre>

<p>Once added, templates appear in the DOM as semantically-neutral script tags:</p>

<pre><code>&lt;script type=&quot;text/mustache&quot; id=&quot;users/listItem&quot;&gt;
  User&#39;s name: {{name}}
&lt;/script&gt;</code></pre>

<p>On the client side, the Spah client will automatically add a <a href='#responding_to_state_changes_with_javascript'>jQuery responder</a> to the path referenced in the <code>data-populate-with</code> attribute, ensuring that the populated content is updated when the state is modified.</p>

<h2 id='using_multiple_operations_on_a_single_element'>Using multiple operations on a single element</h2>

<p>All of the above operations may be combined on a single element. The order in which the operations will run is strictly defined in order of the type of operation. <code>-if</code> operations always run before <code>-unless</code> operations.</p>

<ol>
<li>data-show-if and data-show-unless</li>

<li>data-class-[classname]-if, data-class-[classname]-unless</li>

<li>data-id-[id]-if, data-id-[id]-unless</li>

<li>data-stash-if, data-stash-unless</li>

<li>data-populate-if, data-populate-unless</li>
</ol>

<h2 id='advanced_document_logic_example'>Advanced document logic example</h2>

<p>Let&#8217;s make an advanced example: We want a list of users to default to an &#8220;empty&#8221; state, becoming populated with users if there is a non-empty list of users in the state. If the user list in the state is emptied, then the &#8220;empty&#8221; state should be restored on the element</p>

<p>Because stash operations run before populate operations, the following chain of events will occur:</p>

<ol>
<li>
<p>The element will render in the &#8220;empty&#8221; state, with class &#8220;empty&#8221; applied.</p>
</li>

<li>
<p>If the <code>/users</code> array is empty, it will remain in the empty state</p>
</li>

<li>
<p>If the <code>/users</code> array becomes non-empty:</p>

<ol>
<li>The &#8220;No users found&#8221; element will be stashed</li>

<li>The <code>ul</code> element will be populated using the template</li>

<li>The &#8220;empty&#8221; class will be removed from the <code>ul</code></li>
</ol>
</li>

<li>
<p>If the <code>/users</code> array reverts to an empty state:</p>

<ol>
<li>The &#8220;empty&#8221; class will be removed from the <code>ul</code></li>

<li>The &#8220;No users found&#8221; element will be unstashed into the <code>ul</code>, overwriting the rendered template content.</li>
</ol>
</li>
</ol>

<p>API</p>

<h1 id='example_node_application'>Example Node application</h1>

<h1 id='example_sinatra_application'>Example Sinatra application</h1>
</div> <!-- .section -->

              <div class="section section-sections">
                <div class="section-title">
                  <h3>Sections</h3>
                </div> <!-- .section-title -->
                <div class="section-content">

  <ul class="section-list">
    
  </ul>
              </div> <!-- .section-content -->
            </div> <!-- .section -->

      </div> <!-- #main -->
      
      <div id="footer">
        <p><a href="http://github.com/danski/spah">Spah</a> v0.0.0 API documentation.</p>
        <p>
          
            Last updated on March 09, 2012 at 14:27 UTC.
          
          Generated by <a href="http://pdoc.org">PDoc</a>.
          Uses <a href="http://famfamfam.com/lab/icons/silk/" title="famfamfam.com: Silk Icons">Silk Icons</a> and portions of <a href="http://github.com/280north/aristo/tree/master" title="280north's aristo at master - GitHub">Aristo</a>.
        </p>
        
      </div> <!-- #footer -->

    </div> <!-- #page -->
  </body>
</html>
