Spah: Single-Page Application Helper
====================================

<img src="https://img.skitch.com/20110504-c79qr916mcwtnq4m63uqc3dibq.jpg" />

Contents
--------

[introduction]: #introduction
[server]: #the_server
[client]: #the_client
[state_queries]: #state_queries
[document_logic]: #document_logic
[ruby_helpers]: #you_can_still_write_your_markup_with_ruby
[templating]: #templating_with_mustache
[responders]: #responding_to_state_changes_with_javascript
[eager_state_changes]: #eager_client_state_changes
[rails_example]: #example_rails_application
[sinatra_example]: #example_sinatra_application
[force_synchronous]: #forcing_links_and_forms_to_load_synchronously
[defaults]: #default_client_behaviour

1. [Introduction][introduction]
2. [The server][server]
3. [The client][client]
4. [State queries][state_queries]
5. TODO: [Document logic][document_logic]
6. TODO: [Templating with Mustache][templating]
7. TODO: [Building your markup with ruby][ruby_helpers] (erb, haml, templating, url builders)
8. TODO: [Reacting to state changes with Javascript][responders]
9. [Forcing links and forms to load synchronously][force_synchronous]
10. TODO: [Default client behaviours][defaults] (automatically update doc title from /title path, automatically add async behaviour, automatically manage history)
11. TODO: [Eager client state changes][eager_state_changes] (mark parts of the tree as "expected to get new data" to trigger load notifications. automatically revert to previous state on load failure and dispatch failure event)
12. TODO: [Examples: Example Rails application][rails_example]
13. TODO: [Examples: Example Sinatra application][sinatra_example]

Introduction
------------

Spah is both a server-side rubygem and a client-side javascript library. Together, the two parts are used to build dynamic single-page
web applications that:

* Don't break the web, and keep the document as king. With Spah, every resource may be curled, scraped and indexed just as with a static site.
* Cold boot into full-fledged javascript applications from any of your application's URLs.
* Provide graceful continuation of interface state between pages when an action absolutely must be performed synchronously.

The central concept in Spah is the **state**. Spah manages the state of your application as a hash which may contain more hashes, booleans, 
strings and arrays. You, as the developer of your application, define the overall structure of the state. As an example, the state for this
documentation page might be something like:

       {
         "class": "Spah", // Currently viewing the Spah class
         "method": null, // No specific method selected
         "search-query": "" // No search term entered in search box
       }

On each request to the server, Spah will attach the state in JSON form to the request. The server modifies the state and returns a
new JSON object containing the updates. The Spah client merges the updates into the state and dispatches events to which you may subscribe.

The server
----------
A Spah application is assumed to be a RESTish ruby application - in our examples we'll be using Rails. As always, all validation and data
persistence is handled by your models. All routing by the router, and all request logic in the controllers. Where a Spah app differs is in
the view layer.

*Figure 1: A crap approach to single-page apps*

<img src="https://img.skitch.com/20110504-73a3ftde7d731kbepxg2p7w1.jpg" />

Instead of hiding away template logic in server-side ruby, template logic is moved to a place where both the client AND the server have access
to it - [the document itself][document_logic].

A Spah HTML render takes the **state** and a **prototype layout** and gloms to the two together. The HTML layout contains [logic encoded in HTML5 data
attributes][document_logic], and Spah will pre-process the document **before sending it down the wire**. This way, any view can be cold-rendered by a request
to the appropriate URL, or warm-rendered by an asynchronous state update from the server. In a sense, Spah allows your server-side app to
*behave like a browser* and boot your client-side application to the point of usefulness, before letting the user's actual browser carry
out the rest of the startup process.

*Figure 2: A better approach.*

<img src="https://img.skitch.com/20110504-p13hfga9s4d6x7bpjwrw1gbyjj.jpg" />

For partials, Spah uses [Mustache templates][templating]. All <code>.mustache</code> files in your server-side application are indexed by path on startup
and made available to the rendering chain on both the client and server. Spah automatically injects the templates into your HTML layout using
<code><script type="text/mustache" id="views/my/partial">...</script></code> tags, which are semantically neutral in nature and do not alter
your document's content. Spah will also add a hidden <code>state</code> input to the end of each form in your document containing the current
state, and append the state to link URLs within the current domain - this allows for graceful state handover in no-js environments.

In environments that support JS, the state in forms and links is replaced with the current state on submission/activation.

The client
----------
The Spah client handles things at the browser end. Its primary tasks are:

1. Ensuring that links and forms are submitted asynchronously and that they attach the state when activated (you may also [prevent some links and forms from acting asynchronously][force_synchronous])
2. Ensuring that async requests are submitted with a <code>content-accept</code> header of <code>application/state+json</code>, allowing the server-side application to
determine that this is a warm request and should be responded to with an updated state
3. Re-evaluating and processing any document logic whenever the state is modified
4. Raising path-specific events whenever the state is modified

*Figure 3: A better approach, with added progressive enhancement*

<img src="https://img.skitch.com/20110504-tpqb613eyy46j7f758nqr745n2.jpg" />

For cleanliness, Spah keeps all of its functions, classes and behaviour within the top level <code>Spah</code> object.
Initialising Spah is simple:

     $(document).ready(function() { 
         Spah.init(); 
     });


This is achieved by embedding template logic within the markup using HTML5 data attributes, thus making the same template logic available to both client
and server. When the state is updated by a response from the server, elements with embedded display logic are re-evaluated automatically and the display 
updated accordingly.

You may also bind more advanced behaviours to changes in the state using [jQuery responders][responders] and [state queries][state_queries]

State queries
-------------

The state may be queried on both the client and server by using the state query language, a DSL for querying JSON structures. Let's take an example state with a variety of types:

      {
        hash_one: {foo: "bar", bar: "baz", hash_in_hash: {"foo": "bar-inner"}},
        hash_two: {foo: "bar", bool_one: true, bool_two: false, arr_in_hash: [1,2,3]},
        arr_one: [1,2,3],
        arr_two: [0,1,2],
        arr_three: [],
        bool_one: true,
        bool_two: false
      }

You may retrieve any value using a simple path:

      Spah.state.queryValues("/hash_one"); //-> [{foo: "bar", bar: "baz"}]
      Spah.state.queryValues("/hash_one/foo"); //-> "bar";
      Spah.state.queryValues("/hash_one/arr_in_hash"); //-> "bar";
      Spah.state.queryValues("//foo") //-> ["bar", "bar"];
      
In the last example, a double slash is used to indicate that we want all values named "foo" regardless of their place in the hierarchy. Much like xpath, the query can be scoped:

      Spah.state.queryValues("/hash_one//foo"); //-> ["bar", "bar-inner"];
      
What is actually happening here is that the #queryValues method is getting a set of <code>Spah.Viewstate.select.Result</code> objects back, each of which provides a path and a value for the returned result:

      var results = Spah.state.select("/hash_one//foo"); //-> [Result, Result];
          results[0].path //-> "/hash_one/foo"
          results[0].value //-> "bar"
          results[1].path //-> "/hash_one/hash_in_hash/foo"
          results[1].value //-> "bar-inner"
      
When accessing arrays, strings and hashes, the <code>[index]</code> accessor may be used:

      // Array
      var results = Spah.state.select("/arr_one[0]") //-> [Result]
          results[0].path //-> "/arr_one[0]"
          results[0].value //-> 1
      
      // Hash
          results = Spah.state.select("/hash_one[foo]") -> [Result]
          results[0].path //-> "/hash_one/foo"
          results[0].value //-> "bar"
      
      // String
          results = Spah.state.select("/hash_one/foo[1]") -> [Result]
          results[0].path //-> "/hash_one/foo[1]"
          results[0].value //-> "a"
          
Arrays, strings and hashes also provide the .length property:
          
      var results = Spah.state.select("/arr_one.length") //-> [Result]
          results[0].path //-> "/arr_one.length"
          results[1].value = 3
      
The <code>[]</code> accessor also supports comparators:
      
      // Query for all hashes where the "foo" property is defined and has value "bar":
      var results = Spah.state.select("//[foo=='bar']") //-> [Result, Result]
          results[0].path = "/hash_one/foo"
          results[0].value = "bar"
          results[1].path = "/hash_two/foo"
          results[1].value = "bar"
          
      // Query for all hashes where the "foo" property is defined and has a value matching 
      // the regular expression '^bar'
          results = Spah.state.select("//[foo~='^bar']") //-> 
          results[0]
      
      // Query for all arrays of at least 2 entries in length:
      // Note that the "type" and "length" properties are preceded by a dot.
      // Available types are "Array", "Bool", "Hash", "String"
          results = Spah.state.select("//[.type=='Array' && .length>=2]") -> [Result, Result, Result]
          results[0].path = "/hash_two/arr_in_hash"
          results[0].value = [1,2,3]
          results[1].path = "/arr_one"
          results[1].value = [1,2,3]
          results[2].path = "/arr_two"
          results[2].value = [0,1,2]
          
      // Query for all hashes where the value of key "foo" matches the value found 
      // at /hash_one/foo
      // NOTE: If the subquery returns more than one Result then an exception will be 
      // raised. Be sure to use specific address paths in comparison operations.
          results = Spah.state.select("//[foo==/hash_one/foo]") -> [Result, Result]
          results[0].path = "/hash_one/foo"
          results[0].value = "bar"
          results[1].path = "/hash_two/foo"
          results[1].value = "bar"

Queries may also produce boolean results, using comparators between subqueries:

      // Does the value at /hash_one/foo equal "bar"?
      Spah.state.assert("/hash_one/foo == 'bar'") //-> true. The value is "bar"
      
      // Does the value at /hash_one/foo match the value at /hash_two/foo?
      // NOTE: if comparing the results of more than one query, the results of both 
      // queries must be the same length and must have matching values 
      // although the results DO NOT have to be from the same paths.
      Spah.state.assert("/hash_one/foo == /hash_two/foo") //-> true. Both values are "bar"
      
      // Is the value at /hash_one an array?
      Spah.state.assert("/hash_one.type == 'Array'") //-> false. /hash_one is 'Hash'
      
      // Is arr_one empty?
      Spah.state.assert("/arr_one.length < 1") //-> false. /arr_one has 3 entries.
      
      // Is does arr_three have the same number of entries as arr_one?
      Spah.spate.assert("/arr_three.length == /arr_one.length") //-> false. /arr_three is empty, but /arr_one has 3 items.
      
      // Comparing arrays and hashes: both entities must have the same contents and the same keys in order to achieve equality.
      Spah.state.assert("/hash_two/arr_in_hash == /arr_one") //-> true! both arrays have the same contents in the same order.
      Spah.state.assert("/hash_two/arr_in_hash == /arr_two") //-> false. each array has content distinct from the other.
      
      // Comparing the types of entities
      Spah.state.assert("/hash_one.type == /hash_two.type") //-> true. Both are hashes.
      Spah.state.assert("/hash_one === /hash_two") // -> true, functionally identical to the above
      
      // Comparing query result counts: use the #count property at the end of your query
      Spah.state.assert("/hash_one[foo~='bar']#count > 3") //-> false. There's only one item returned by this query.
            
      // And of course, simple truthiness assertions:
      // Basic assertions return true if the associated query returns >0 results and if any of those results
      // have values other than false or null.
      Spah.state.assert("/bool_one") //-> true
      Spah.state.assert("/bool_two") //-> false
      Spah.state.assert("/key_does_not_exist") //-> false
      Spah.state.assert("/arr_one") //-> true

Document logic
--------------

Templating with Mustache
------------------------


Forcing links and forms to load synchronously
---------------------------------------------

To prevent Spah from adding asynchronous behaviour, add the <code>data-async="false"</code> attribute to the link or form element:

    language:html
    
    <a href="/login" data-async="false">Log in</a>
    
    <form action="/login" method="POST" data-async="false">
      ...
    </form>