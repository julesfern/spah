<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Class: Spah::SpahQL::QueryParser</title>
<link rel="stylesheet" href="../../css/style.css" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="../../css/common.css" type="text/css" media="screen" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  relpath = '../..';
  if (relpath != '') relpath += '/';
</script>
<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/app.js"></script>

  </head>
  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>
    
    <div id="header">
      <div id="menu">
  
    <a href="../../_index.html">Index (Q)</a> &raquo; 
    <span class='title'><span class='object_link'><a href="../../Spah.html" title="Spah (module)">Spah</a></span></span> &raquo; <span class='title'><span class='object_link'><a href="../SpahQL.html" title="Spah::SpahQL (module)">SpahQL</a></span></span>
     &raquo; 
    <span class="title">QueryParser</span>
  
  
  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  <a id="class_list_link" href="#">Class List</a>
  <a id="method_list_link" href="#">Method List</a>
  <a id ="file_list_link" href="#">File List</a>
</div>

      <div class="clear"></div>
    </div>
    
    <iframe id="search_frame"></iframe>
    
    <div id="content"><h1>Class: Spah::SpahQL::QueryParser
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName">Object</span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next">Spah::SpahQL::QueryParser</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/spahql/query_parser.rb</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>
Responsible for converting string SpahQL queries into runnable
Spah::SpahQL::Query instances. Also maintains an in-memory cache of
previously-parsed queries for speed.
</p>


  </div>
</div>
<div class="tags">
  
</div>
  <h2>Constant Summary</h2>
  
    <dl class="constants">
      
        <dt id="COMPARISON_STRICT_EQUALITY-constant" class="">COMPARISON_STRICT_EQUALITY =
          <div class="docstring">
  <div class="discussion">
    <p>
The strict equality operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;==&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_ROUGH_EQUALITY-constant" class="">COMPARISON_ROUGH_EQUALITY =
          <div class="docstring">
  <div class="discussion">
    <p>
The rough equality operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;=~&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_INEQUALITY-constant" class="">COMPARISON_INEQUALITY =
          <div class="docstring">
  <div class="discussion">
    <p>
The inequality operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;!=&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_LT-constant" class="">COMPARISON_LT =
          <div class="docstring">
  <div class="discussion">
    <p>
The less than operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;&lt;&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_GT-constant" class="">COMPARISON_GT =
          <div class="docstring">
  <div class="discussion">
    <p>
The greater than operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;&gt;&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_LTE-constant" class="">COMPARISON_LTE =
          <div class="docstring">
  <div class="discussion">
    <p>
The less than (or equal to) operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;&lt;=&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_GTE-constant" class="">COMPARISON_GTE =
          <div class="docstring">
  <div class="discussion">
    <p>
The greater than (or equal to) operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;&gt;=&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_JOINT_SET-constant" class="">COMPARISON_JOINT_SET =
          <div class="docstring">
  <div class="discussion">
    <p>
The joint set operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;}~{&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_SUPERSET-constant" class="">COMPARISON_SUPERSET =
          <div class="docstring">
  <div class="discussion">
    <p>
The superset operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;}&gt;{&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_SUBSET-constant" class="">COMPARISON_SUBSET =
          <div class="docstring">
  <div class="discussion">
    <p>
The subset operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;}&lt;{&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_DISJOINT_SET-constant" class="">COMPARISON_DISJOINT_SET =
          <div class="docstring">
  <div class="discussion">
    <p>
The disjoint set operator as used in the parser
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;}!{&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="COMPARISON_OPERATORS-constant" class="">COMPARISON_OPERATORS =
          <div class="docstring">
  <div class="discussion">
    <p>
All valid SpahQL operators collected into an array for convenience.
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='lbrack token'>[</span>
  <span class='COMPARISON_STRICT_EQUALITY constant id'>COMPARISON_STRICT_EQUALITY</span><span class='comma token'>,</span> <span class='COMPARISON_ROUGH_EQUALITY constant id'>COMPARISON_ROUGH_EQUALITY</span><span class='comma token'>,</span> <span class='COMPARISON_INEQUALITY constant id'>COMPARISON_INEQUALITY</span><span class='comma token'>,</span>
  <span class='COMPARISON_LT constant id'>COMPARISON_LT</span><span class='comma token'>,</span> <span class='COMPARISON_GT constant id'>COMPARISON_GT</span><span class='comma token'>,</span> <span class='COMPARISON_LTE constant id'>COMPARISON_LTE</span><span class='comma token'>,</span> <span class='COMPARISON_GTE constant id'>COMPARISON_GTE</span><span class='comma token'>,</span>
  <span class='COMPARISON_JOINT_SET constant id'>COMPARISON_JOINT_SET</span><span class='comma token'>,</span> <span class='COMPARISON_SUPERSET constant id'>COMPARISON_SUPERSET</span><span class='comma token'>,</span> <span class='COMPARISON_SUBSET constant id'>COMPARISON_SUBSET</span><span class='comma token'>,</span> <span class='COMPARISON_DISJOINT_SET constant id'>COMPARISON_DISJOINT_SET</span>
<span class='rbrack token'>]</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_QUOTE_SINGLE-constant" class="">ATOM_QUOTE_SINGLE =
          <div class="docstring">
  <div class="discussion">
    <p>
A single quote
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;'&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_QUOTE_DOUBLE-constant" class="">ATOM_QUOTE_DOUBLE =
          <div class="docstring">
  <div class="discussion">
    <p>
A double quote
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>'&quot;'</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_ESCAPE-constant" class="">ATOM_ESCAPE =
          <div class="docstring">
  <div class="discussion">
    <p>
A string escape
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>'\\'</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_NUMERIC_POINT-constant" class="">ATOM_NUMERIC_POINT =
          <div class="docstring">
  <div class="discussion">
    <p>
A decimal point
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;.&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_NUMERIC_NEGATIVE-constant" class="">ATOM_NUMERIC_NEGATIVE =
          <div class="docstring">
  <div class="discussion">
    <p>
The prefix for negative numbers
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;-&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_BOOLEAN_TRUE-constant" class="">ATOM_BOOLEAN_TRUE =
          <div class="docstring">
  <div class="discussion">
    <p>
A boolean true
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;true&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_BOOLEAN_FALSE-constant" class="">ATOM_BOOLEAN_FALSE =
          <div class="docstring">
  <div class="discussion">
    <p>
A boolean false
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;false&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_SET_START-constant" class="">ATOM_SET_START =
          <div class="docstring">
  <div class="discussion">
    <p>
The opening character for a set literal
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;{&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_SET_END-constant" class="">ATOM_SET_END =
          <div class="docstring">
  <div class="discussion">
    <p>
The terminating character for a set literal
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;}&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_SET_ARRAY_DELIMITER-constant" class="">ATOM_SET_ARRAY_DELIMITER =
          <div class="docstring">
  <div class="discussion">
    <p>
The delimiter for multi-value sets
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;,&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_SET_RANGE_DELIMITER-constant" class="">ATOM_SET_RANGE_DELIMITER =
          <div class="docstring">
  <div class="discussion">
    <p>
The delimter for range sets
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;..&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_PATH_DELIMITER-constant" class="">ATOM_PATH_DELIMITER =
          <div class="docstring">
  <div class="discussion">
    <p>
The delimiter expected at the beginning of any path segment
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;/&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_PATH_ROOT-constant" class="">ATOM_PATH_ROOT =
          <div class="docstring">
  <div class="discussion">
    <p>
The prefix for any query that is forced to run against the root data scope
rather than its local scope.
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;$&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_FILTER_QUERY_START-constant" class="">ATOM_FILTER_QUERY_START =
          <div class="docstring">
  <div class="discussion">
    <p>
The opening character for an inline filter query
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;[&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_FILTER_QUERY_END-constant" class="">ATOM_FILTER_QUERY_END =
          <div class="docstring">
  <div class="discussion">
    <p>
The terminating character for an inline filter query
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;]&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_PROPERTY_IDENTIFIER-constant" class="">ATOM_PROPERTY_IDENTIFIER =
          <div class="docstring">
  <div class="discussion">
    <p>
The prefix for a property or other virtual key when used in a path segment
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;.&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="ATOM_PATH_WILDCARD-constant" class="">ATOM_PATH_WILDCARD =
          <div class="docstring">
  <div class="discussion">
    <p>
The wildcard glyph for use in path components
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;*&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_STRING_LITERAL-constant" class="">TOKEN_STRING_LITERAL =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing a string literal in or out of a set
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_STRING_LITERAL&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_NUMERIC_LITERAL-constant" class="">TOKEN_NUMERIC_LITERAL =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing an integer or floating-point literal, in or out of a
set
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_NUMERIC_LITERAL&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_BOOLEAN_LITERAL-constant" class="">TOKEN_BOOLEAN_LITERAL =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing a boolean literal i.e. true or false
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_BOOLEAN_LITERAL&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_SET_LITERAL-constant" class="">TOKEN_SET_LITERAL =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing a set literal
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_SET_LITERAL&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_SELECTION_QUERY-constant" class="">TOKEN_SELECTION_QUERY =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing one or more path components chained into a selection
query
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_SELECTION_QUERY&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="TOKEN_COMPARISON_OPERATOR-constant" class="">TOKEN_COMPARISON_OPERATOR =
          <div class="docstring">
  <div class="discussion">
    <p>
A token representing any of the comparison operators specified in
COMPARISON_OPERATORS
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='string val'>&quot;TOKEN_COMPARISON_OPERATOR&quot;</span><span class='dot token'>.</span><span class='freeze identifier id'>freeze</span>
</pre></dd>
      
        <dt id="query_cache-classvariable" class="">@@query_cache =
          <div class="docstring">
  <div class="discussion">
    <p>
In-memory query cache, keyed by string representation (with spaces removed)
</p>


  </div>
</div>
<div class="tags">
  
</div>
        </dt>
        <dd><pre class="code"><span class='lbrace token'>{</span><span class='rbrace token'>}</span>
</pre></dd>
      
    </dl>
  



  
    <h2>
      Class Method Summary
      <small>(<a href="#" class="summary_toggle">collapse</a>)</small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cache_query-class_method" title="cache_query (class method)">+ (Object) <strong>cache_query</strong>(query, query_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Stashes a query in the in-memory cache.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#cached_query-class_method" title="cached_query (class method)">+ (Spah::SpahQL::Query<sup>?</sup>) <strong>cached_query</strong>(query_str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Returns a pre-parsed query for the given query string, or nil.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#parse_query-class_method" title="parse_query (class method)">+ (Spah::SpahQL::Query) <strong>parse_query</strong>(str) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Parses a string query into a runnable parsed query instance, or retrieves a
pre-parsed query from memory if the given string has already been parsed.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_boolean_literal-class_method" title="read_ahead_boolean_literal (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_boolean_literal</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects boolean literals at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_comparison_operator-class_method" title="read_ahead_comparison_operator (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_comparison_operator</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects comparison operators at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_filter_query-class_method" title="read_ahead_filter_query (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_filter_query</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects a filter query at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_inline_variable_reference-class_method" title="read_ahead_inline_variable_reference (class method)">+ (Object) <strong>read_ahead_inline_variable_reference</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Reads ahead for alphanumeric, underscore and hyphen characters.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_numeric_literal-class_method" title="read_ahead_numeric_literal (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_numeric_literal</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects numeric literals at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_path_component-class_method" title="read_ahead_path_component (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_path_component</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects a path component at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_selection_query-class_method" title="read_ahead_selection_query (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_selection_query</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects a selection query at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_set_literal-class_method" title="read_ahead_set_literal (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_set_literal</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects a set literal at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_string_literal-class_method" title="read_ahead_string_literal (class method)">+ (Array<sup>?</sup>) <strong>read_ahead_string_literal</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects string literals at the given index in the given string query.
</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#read_ahead_token-class_method" title="read_ahead_token (class method)">+ (Hash<sup>?</sup>) <strong>read_ahead_token</strong>(i, query) </a>
    

    
  </span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>
Detects a token of any type and returns the resume index and the found
token, along with the type of token encountered.
</p>
</div></span>
  
</li>

      
    </ul>
  



  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>
    
    
      <div class="method_details first">
  <p class="signature first" id="cache_query-class_method">
  
    + (<tt>Object</tt>) <strong>cache_query</strong>(query, query_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Stashes a query in the in-memory cache
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Query.html" title="Spah::SpahQL::Query (class)">Spah::SpahQL::Query</a></span></tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The parsed query instance
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query_str</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string representation to be used as a key for this cached query.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


96</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 96</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='cache_query identifier id'>cache_query</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='comma token'>,</span> <span class='query_str identifier id'>query_str</span><span class='rparen token'>)</span> <span class='@@query_cache ivar id'>@@query_cache</span><span class='lbrack token'>[</span><span class='query_str identifier id'>query_str</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span> <span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="cached_query-class_method">
  
    + (<tt><span class='object_link'><a href="Query.html" title="Spah::SpahQL::Query (class)">Spah::SpahQL::Query</a></span></tt><sup>?</sup>) <strong>cached_query</strong>(query_str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Returns a pre-parsed query for the given query string, or nil
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query_str</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string representation of the query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Query.html" title="Spah::SpahQL::Query (class)">Spah::SpahQL::Query</a></span></tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
The query, if it exists in memory. Otherwise nil will be returned.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


91</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 91</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='cached_query identifier id'>cached_query</span><span class='lparen token'>(</span><span class='query_str identifier id'>query_str</span><span class='rparen token'>)</span> <span class='@@query_cache ivar id'>@@query_cache</span><span class='lbrack token'>[</span><span class='query_str identifier id'>query_str</span><span class='rbrack token'>]</span> <span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="parse_query-class_method">
  
    + (<tt><span class='object_link'><a href="Query.html" title="Spah::SpahQL::Query (class)">Spah::SpahQL::Query</a></span></tt>) <strong>parse_query</strong>(str) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Parses a string query into a runnable parsed query instance, or retrieves a
pre-parsed query from memory if the given string has already been parsed.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>str</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string representation of the query.
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt><span class='object_link'><a href="Query.html" title="Spah::SpahQL::Query (class)">Spah::SpahQL::Query</a></span></tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
the string parsed into a runnable parsed query instance
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 103</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='str identifier id'>str</span><span class='rparen token'>)</span>
        <span class='query identifier id'>query</span> <span class='assign token'>=</span> <span class='str identifier id'>str</span><span class='dot token'>.</span><span class='gsub identifier id'>gsub</span><span class='lparen token'>(</span><span class='string val'>&quot; &quot;</span><span class='comma token'>,</span> <span class='string val'>&quot;&quot;</span><span class='rparen token'>)</span> <span class='comment val'># Strip spaces from the query string</span>

        <span class='comment val'># Pull it from the cache and return if it exists</span>
        <span class='cached_query identifier id'>cached_query</span> <span class='assign token'>=</span> <span class='cached_query identifier id'>cached_query</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='cached_query identifier id'>cached_query</span> <span class='if if_mod kw'>if</span> <span class='cached_query identifier id'>cached_query</span>

        <span class='comment val'># Nothing in the cache, prep a new instance</span>
        <span class='parsed_query identifier id'>parsed_query</span> <span class='assign token'>=</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Query constant id'>Query</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='rparen token'>)</span>
        
        <span class='i identifier id'>i</span><span class='assign token'>=</span><span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
        <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
          <span class='comment val'># Handle read result</span>
          <span class='i identifier id'>i</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
          <span class='token_type identifier id'>token_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
          <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='token_type identifier id'>token_type</span> <span class='eq op'>==</span> <span class='TOKEN_COMPARISON_OPERATOR constant id'>TOKEN_COMPARISON_OPERATOR</span><span class='rparen token'>)</span>
            <span class='comment val'># comparison operator, error if != one token stashed</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='primary_token identifier id'>primary_token</span> <span class='andop op'>&amp;&amp;</span> <span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='secondary_token identifier id'>secondary_token</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span><span class='rparen token'>)</span>
              <span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='comparison_operator identifier id'>comparison_operator</span> <span class='assign token'>=</span> <span class='token identifier id'>token</span>
              <span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='assertion identifier id'>assertion</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Found unexpected TOKEN_COMPARISON_OPERATOR, expected EOL&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: valid comparison operator</span>
          <span class='else else kw'>else</span>
            <span class='comment val'># Stash simple types - strings, numerics, booleans - into a set</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='token_type identifier id'>token_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># Convert to set literal</span>
              <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='rbrace token'>}</span>
              <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span>
            <span class='end end kw'>end</span>
            
            <span class='comment val'># Now set query tokens appropriately</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='primary_token identifier id'>primary_token</span><span class='rparen token'>)</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='comparison_operator identifier id'>comparison_operator</span><span class='rparen token'>)</span>
                <span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='secondary_token identifier id'>secondary_token</span> <span class='assign token'>=</span> <span class='token identifier id'>token</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># invalid: two tokens and no comparison?</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                      <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                      <span class='dstring node'>&quot;Found unexpected #{token_type}, expected EOL or TOKEN_COMPARISON_OPERATOR&quot;</span>
                      <span class='rparen token'>)</span>
              <span class='end end kw'>end</span>
            <span class='else else kw'>else</span>
              <span class='parsed_query identifier id'>parsed_query</span><span class='dot token'>.</span><span class='primary_token identifier id'>primary_token</span> <span class='assign token'>=</span> <span class='token identifier id'>token</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: decide storage attribute</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token types</span>
        <span class='end end kw'>end</span><span class='comment val'>#while</span>
        
        <span class='return return kw'>return</span> <span class='cache_query identifier id'>cache_query</span><span class='lparen token'>(</span><span class='parsed_query identifier id'>parsed_query</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a token of any type and returns the resume index and the found token, along with the type of token encountered.</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Hash, nil] A hash with keys :resume_at, :token, :token_type, or nil.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_COMPARISON_OPERATOR constant id'>TOKEN_COMPARISON_OPERATOR</span> 
        <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span>
        <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_numeric_literal identifier id'>read_ahead_numeric_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span> 
        <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span>
        <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span>
        <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span> 
        <span class='end end kw'>end</span>
        
        <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='r identifier id'>r</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrace token'>{</span><span class='symbol val'>:resume_at</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:token</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:token_type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='type identifier id'>type</span><span class='rbrace token'>}</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>        
      <span class='end end kw'>end</span>

      <span class='comment val'># Detects string literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_QUOTE_SINGLE constant id'>ATOM_QUOTE_SINGLE</span> <span class='or or kw'>or</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_QUOTE_DOUBLE constant id'>ATOM_QUOTE_DOUBLE</span><span class='rparen token'>)</span>
          <span class='quote_type identifier id'>quote_type</span> <span class='assign token'>=</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='str identifier id'>str</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='true true kw'>true</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='comment val'># Run through until terminator found</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='lt op'>&lt;</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='rparen token'>)</span>
              <span class='comment val'># unexpected EOL</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Encountered EOL when expecting #{(quote_type==ATOM_QUOTE_SINGLE)? &quot;ATOM_QUOTE_SINGLE&quot; : &quot;ATOM_QUOTE_DOUBLE&quot;}&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='quote_type identifier id'>quote_type</span><span class='rparen token'>)</span>
              <span class='comment val'># string terminated</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='break break kw'>break</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_ESCAPE constant id'>ATOM_ESCAPE</span><span class='rparen token'>)</span>
              <span class='comment val'># escape, skip ahead</span>
              <span class='str identifier id'>str</span> <span class='lshft op'>&lt;&lt;</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># build string</span>
              <span class='str identifier id'>str</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
            <span class='end end kw'>end</span> <span class='comment val'>#if: character match</span>
          <span class='end end kw'>end</span> <span class='comment val'>#while</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='str identifier id'>str</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span> <span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects numeric literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_numeric_literal identifier id'>read_ahead_numeric_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='numreg identifier id'>numreg</span> <span class='assign token'>=</span> <span class='regexp val'>/\d/</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span> <span class='or or kw'>or</span> <span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_NEGATIVE constant id'>ATOM_NUMERIC_NEGATIVE</span> <span class='and and kw'>and</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='num identifier id'>num</span> <span class='assign token'>=</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='false false kw'>false</span><span class='semicolon token'>;</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='true true kw'>true</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='lt op'>&lt;</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='rparen token'>)</span>
              <span class='comment val'># EOL</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_POINT constant id'>ATOM_NUMERIC_POINT</span><span class='rparen token'>)</span>
              <span class='comment val'># found point</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span>
                <span class='comment val'># Rewind and surrender</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='end end kw'>end</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># found more numerics, append to token</span>
              <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># found non-numeric</span>
              <span class='break break kw'>break</span>
            <span class='end end kw'>end</span> <span class='comment val'>#if: character match</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lparen token'>(</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_f identifier id'>to_f</span> <span class='colon op'>:</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span> <span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects boolean literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='true true kw'>true</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='false false kw'>false</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects comparison operators at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>3</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span>  
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>2</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a selection query at the given index in the given string query.</span>
      <span class='comment val'># A selection query may be composed of an optional root flag followed by one or more</span>
      <span class='comment val'># path components, read using read_ahead_path_component.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span> <span class='orop op'>||</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:use_root</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:path_components</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrace token'>}</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span>
          
          <span class='comment val'># Set root flag if found</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='neq op'>!=</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Found unexpected character '&quot;</span><span class='plus op'>+</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='plus op'>+</span><span class='string val'>&quot;', expected ATOM_PATH_DELIMITER&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: root character not followed by query</span>
            <span class='comment val'># Exception dealt with, now set root flag and wind ahead</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:use_root</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: root query</span>
          
          <span class='comment val'># Now read in the path components</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:path_components</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query_token identifier id'>query_token</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>        
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a path component at the given index in the given string query.</span>
      <span class='comment val'># A path component is composed of one or more path delimiters follows by a key or property name</span>
      <span class='comment val'># and an optional set of filter queries, read ahead using read_ahead_filter_query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span>
          <span class='comment val'># Set up the blank path component</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:property</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:recursive</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:filter_queries</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
          <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># 1. Handle recursive</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:recursive</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: recursive</span>
          
          <span class='comment val'># 2. Wildcards</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>          
          <span class='else else kw'>else</span>
          <span class='comment val'># 3. Identify key type</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PROPERTY_IDENTIFIER constant id'>ATOM_PROPERTY_IDENTIFIER</span><span class='rparen token'>)</span>
              <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Too many ATOM_PATH_DELIMITER in a row - maximum allowed is two.&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: property identifier found or too many slashes</span>
            
            <span class='comment val'># 4. Read key or property name</span>
            <span class='keyname_result identifier id'>keyname_result</span> <span class='assign token'>=</span> <span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span> <span class='and and kw'>and</span> <span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Unexpected character #{query[j,1]}, expected TOKEN_PROPERTY&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='rparen token'>)</span>
              <span class='comment val'># stash found key</span>
              <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='lparen token'>(</span><span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='symbol val'>:property</span> <span class='colon op'>:</span> <span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='end end kw'>end</span><span class='comment val'>#if:keyname or propertyname found</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: wildcard/property/key</span>
          
          <span class='comment val'># 5. Read filter queries</span>
          <span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:filter_queries</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span>
          
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='path_component identifier id'>path_component</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a filter query at the given index in the given string query.</span>
      <span class='comment val'># A filter query is a selection or assertion query wrapped in the ATOM_FILTER_QUERY_START and</span>
      <span class='comment val'># ATOM_FILTER_QUERY_END character atoms and is parsed as an independent using parse_query. </span>
      <span class='comment val'># </span>
      <span class='comment val'># This has the benefit of putting filter queries into the pre-parsed query cache.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_boolean_literal-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_boolean_literal</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects boolean literals at the given index in the given string query.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


263
264
265
266
267</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 263</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
  <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='true true kw'>true</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='rparen token'>)</span> 
  <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='false false kw'>false</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='rparen token'>)</span>
  <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_comparison_operator-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_comparison_operator</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects comparison operators at the given index in the given string query.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


274
275
276
277
278
279</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 274</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
  <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>3</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span>  
  <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>2</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
  <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
  <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_filter_query-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_filter_query</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects a filter query at the given index in the given string query. A
filter query is a selection or assertion query wrapped in the
ATOM_FILTER_QUERY_START and ATOM_FILTER_QUERY_END character atoms and is
parsed as an independent using parse_query.
</p>
<p>
This has the benefit of putting filter queries into the pre-parsed query
cache.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 393</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_inline_variable_reference-class_method">
  
    + (<tt>Object</tt>) <strong>read_ahead_inline_variable_reference</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Reads ahead for alphanumeric, underscore and hyphen characters
</p>


  </div>
</div>
<div class="tags">
  
</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


522
523
524
525
526
527
528
529
530
531
532</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 522</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
     <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
     <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
     <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
       <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
       <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
     <span class='end end kw'>end</span><span class='comment val'>#while</span>
     <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
  <span class='end end kw'>end</span>
  
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_numeric_literal-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_numeric_literal</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects numeric literals at the given index in the given string query.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 225</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_numeric_literal identifier id'>read_ahead_numeric_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='numreg identifier id'>numreg</span> <span class='assign token'>=</span> <span class='regexp val'>/\d/</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span> <span class='or or kw'>or</span> <span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_NEGATIVE constant id'>ATOM_NUMERIC_NEGATIVE</span> <span class='and and kw'>and</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='num identifier id'>num</span> <span class='assign token'>=</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='false false kw'>false</span><span class='semicolon token'>;</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='true true kw'>true</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='lt op'>&lt;</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='rparen token'>)</span>
              <span class='comment val'># EOL</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_POINT constant id'>ATOM_NUMERIC_POINT</span><span class='rparen token'>)</span>
              <span class='comment val'># found point</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span>
                <span class='comment val'># Rewind and surrender</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='end end kw'>end</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># found more numerics, append to token</span>
              <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># found non-numeric</span>
              <span class='break break kw'>break</span>
            <span class='end end kw'>end</span> <span class='comment val'>#if: character match</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lparen token'>(</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_f identifier id'>to_f</span> <span class='colon op'>:</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span> <span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects boolean literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='true true kw'>true</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='false false kw'>false</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects comparison operators at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>3</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span>  
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>2</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a selection query at the given index in the given string query.</span>
      <span class='comment val'># A selection query may be composed of an optional root flag followed by one or more</span>
      <span class='comment val'># path components, read using read_ahead_path_component.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span> <span class='orop op'>||</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:use_root</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:path_components</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrace token'>}</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span>
          
          <span class='comment val'># Set root flag if found</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='neq op'>!=</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Found unexpected character '&quot;</span><span class='plus op'>+</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='plus op'>+</span><span class='string val'>&quot;', expected ATOM_PATH_DELIMITER&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: root character not followed by query</span>
            <span class='comment val'># Exception dealt with, now set root flag and wind ahead</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:use_root</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: root query</span>
          
          <span class='comment val'># Now read in the path components</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:path_components</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query_token identifier id'>query_token</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>        
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a path component at the given index in the given string query.</span>
      <span class='comment val'># A path component is composed of one or more path delimiters follows by a key or property name</span>
      <span class='comment val'># and an optional set of filter queries, read ahead using read_ahead_filter_query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span>
          <span class='comment val'># Set up the blank path component</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:property</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:recursive</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:filter_queries</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
          <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># 1. Handle recursive</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:recursive</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: recursive</span>
          
          <span class='comment val'># 2. Wildcards</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>          
          <span class='else else kw'>else</span>
          <span class='comment val'># 3. Identify key type</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PROPERTY_IDENTIFIER constant id'>ATOM_PROPERTY_IDENTIFIER</span><span class='rparen token'>)</span>
              <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Too many ATOM_PATH_DELIMITER in a row - maximum allowed is two.&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: property identifier found or too many slashes</span>
            
            <span class='comment val'># 4. Read key or property name</span>
            <span class='keyname_result identifier id'>keyname_result</span> <span class='assign token'>=</span> <span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span> <span class='and and kw'>and</span> <span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Unexpected character #{query[j,1]}, expected TOKEN_PROPERTY&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='rparen token'>)</span>
              <span class='comment val'># stash found key</span>
              <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='lparen token'>(</span><span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='symbol val'>:property</span> <span class='colon op'>:</span> <span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='end end kw'>end</span><span class='comment val'>#if:keyname or propertyname found</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: wildcard/property/key</span>
          
          <span class='comment val'># 5. Read filter queries</span>
          <span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:filter_queries</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span>
          
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='path_component identifier id'>path_component</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a filter query at the given index in the given string query.</span>
      <span class='comment val'># A filter query is a selection or assertion query wrapped in the ATOM_FILTER_QUERY_START and</span>
      <span class='comment val'># ATOM_FILTER_QUERY_END character atoms and is parsed as an independent using parse_query. </span>
      <span class='comment val'># </span>
      <span class='comment val'># This has the benefit of putting filter queries into the pre-parsed query cache.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_path_component-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_path_component</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects a path component at the given index in the given string query. A
path component is composed of one or more path delimiters follows by a key
or property name and an optional set of filter queries, read ahead using
read_ahead_filter_query.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 327</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span>
          <span class='comment val'># Set up the blank path component</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:property</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:recursive</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:filter_queries</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
          <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># 1. Handle recursive</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:recursive</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: recursive</span>
          
          <span class='comment val'># 2. Wildcards</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>          
          <span class='else else kw'>else</span>
          <span class='comment val'># 3. Identify key type</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PROPERTY_IDENTIFIER constant id'>ATOM_PROPERTY_IDENTIFIER</span><span class='rparen token'>)</span>
              <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Too many ATOM_PATH_DELIMITER in a row - maximum allowed is two.&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: property identifier found or too many slashes</span>
            
            <span class='comment val'># 4. Read key or property name</span>
            <span class='keyname_result identifier id'>keyname_result</span> <span class='assign token'>=</span> <span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span> <span class='and and kw'>and</span> <span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Unexpected character #{query[j,1]}, expected TOKEN_PROPERTY&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='rparen token'>)</span>
              <span class='comment val'># stash found key</span>
              <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='lparen token'>(</span><span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='symbol val'>:property</span> <span class='colon op'>:</span> <span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='end end kw'>end</span><span class='comment val'>#if:keyname or propertyname found</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: wildcard/property/key</span>
          
          <span class='comment val'># 5. Read filter queries</span>
          <span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:filter_queries</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span>
          
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='path_component identifier id'>path_component</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a filter query at the given index in the given string query.</span>
      <span class='comment val'># A filter query is a selection or assertion query wrapped in the ATOM_FILTER_QUERY_START and</span>
      <span class='comment val'># ATOM_FILTER_QUERY_END character atoms and is parsed as an independent using parse_query. </span>
      <span class='comment val'># </span>
      <span class='comment val'># This has the benefit of putting filter queries into the pre-parsed query cache.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_selection_query-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_selection_query</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects a selection query at the given index in the given string query. A
selection query may be composed of an optional root flag followed by one or
more path components, read using read_ahead_path_component.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 288</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span> <span class='orop op'>||</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:use_root</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:path_components</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrace token'>}</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span>
          
          <span class='comment val'># Set root flag if found</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='neq op'>!=</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Found unexpected character '&quot;</span><span class='plus op'>+</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='plus op'>+</span><span class='string val'>&quot;', expected ATOM_PATH_DELIMITER&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: root character not followed by query</span>
            <span class='comment val'># Exception dealt with, now set root flag and wind ahead</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:use_root</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: root query</span>
          
          <span class='comment val'># Now read in the path components</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:path_components</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query_token identifier id'>query_token</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>        
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a path component at the given index in the given string query.</span>
      <span class='comment val'># A path component is composed of one or more path delimiters follows by a key or property name</span>
      <span class='comment val'># and an optional set of filter queries, read ahead using read_ahead_filter_query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span>
          <span class='comment val'># Set up the blank path component</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:property</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:recursive</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:filter_queries</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
          <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># 1. Handle recursive</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:recursive</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: recursive</span>
          
          <span class='comment val'># 2. Wildcards</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>          
          <span class='else else kw'>else</span>
          <span class='comment val'># 3. Identify key type</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PROPERTY_IDENTIFIER constant id'>ATOM_PROPERTY_IDENTIFIER</span><span class='rparen token'>)</span>
              <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Too many ATOM_PATH_DELIMITER in a row - maximum allowed is two.&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: property identifier found or too many slashes</span>
            
            <span class='comment val'># 4. Read key or property name</span>
            <span class='keyname_result identifier id'>keyname_result</span> <span class='assign token'>=</span> <span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span> <span class='and and kw'>and</span> <span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Unexpected character #{query[j,1]}, expected TOKEN_PROPERTY&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='rparen token'>)</span>
              <span class='comment val'># stash found key</span>
              <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='lparen token'>(</span><span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='symbol val'>:property</span> <span class='colon op'>:</span> <span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='end end kw'>end</span><span class='comment val'>#if:keyname or propertyname found</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: wildcard/property/key</span>
          
          <span class='comment val'># 5. Read filter queries</span>
          <span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:filter_queries</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span>
          
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='path_component identifier id'>path_component</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a filter query at the given index in the given string query.</span>
      <span class='comment val'># A filter query is a selection or assertion query wrapped in the ATOM_FILTER_QUERY_START and</span>
      <span class='comment val'># ATOM_FILTER_QUERY_END character atoms and is parsed as an independent using parse_query. </span>
      <span class='comment val'># </span>
      <span class='comment val'># This has the benefit of putting filter queries into the pre-parsed query cache.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_set_literal-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_set_literal</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects a set literal at the given index in the given string query. A set
literal is composed of one or more string literals, numeric literals,
boolean literals or selection queries wrapped in the ATOM_SET_START and
ATOM_SET_END character atoms.
</p>
<p>
Within the set, selection queries are parsed and cached using parse_query.
The ATOM_SET_ARRAY_DELIMITER is used to separate values. Alternatively the
ATOM_SET_RANGE_DELIMITER may be used to create a macro or &quot;range&quot;
set containing a numeric or alphabetic range. The two types of delimiters
may not be mixed.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 448</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
      <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
      <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
        <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
        <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
        <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
        <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
        
        <span class='comment val'># Empty sets</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
           <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
        
        <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
        <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
        <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
          <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
          <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
            <span class='comment val'># wind ahead</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
            <span class='comment val'># stash in set</span>
            <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
            <span class='comment val'># find delimiter or closing bracket</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
              <span class='comment val'># found array delimiter</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
              <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
              <span class='comment val'># found range delimiter</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                <span class='comment val'># mixed delimiters, throw wobbler</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
              <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
              <span class='comment val'># end set</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='break break kw'>break</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># dunno, throw toys out the pram</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
          <span class='else else kw'>else</span>
            <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                   <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                   <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                   <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
        <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

        <span class='comment val'># Return match</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
        
      <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
      <span class='comment val'># No match</span>
      <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
    <span class='end end kw'>end</span>
    
    <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
    <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
       <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
       <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
       <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
         <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
         <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
       <span class='end end kw'>end</span><span class='comment val'>#while</span>
       <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
    <span class='end end kw'>end</span>
    
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_string_literal-class_method">
  
    + (<tt>Array</tt><sup>?</sup>) <strong>read_ahead_string_literal</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects string literals at the given index in the given string query.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Array</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
An array in the form [resumeIndex, foundToken], or nil if no token was
found.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 187</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_QUOTE_SINGLE constant id'>ATOM_QUOTE_SINGLE</span> <span class='or or kw'>or</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_QUOTE_DOUBLE constant id'>ATOM_QUOTE_DOUBLE</span><span class='rparen token'>)</span>
          <span class='quote_type identifier id'>quote_type</span> <span class='assign token'>=</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='str identifier id'>str</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='true true kw'>true</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='comment val'># Run through until terminator found</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='lt op'>&lt;</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='rparen token'>)</span>
              <span class='comment val'># unexpected EOL</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Encountered EOL when expecting #{(quote_type==ATOM_QUOTE_SINGLE)? &quot;ATOM_QUOTE_SINGLE&quot; : &quot;ATOM_QUOTE_DOUBLE&quot;}&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='quote_type identifier id'>quote_type</span><span class='rparen token'>)</span>
              <span class='comment val'># string terminated</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='break break kw'>break</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_ESCAPE constant id'>ATOM_ESCAPE</span><span class='rparen token'>)</span>
              <span class='comment val'># escape, skip ahead</span>
              <span class='str identifier id'>str</span> <span class='lshft op'>&lt;&lt;</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># build string</span>
              <span class='str identifier id'>str</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
            <span class='end end kw'>end</span> <span class='comment val'>#if: character match</span>
          <span class='end end kw'>end</span> <span class='comment val'>#while</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='str identifier id'>str</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span> <span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects numeric literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_numeric_literal identifier id'>read_ahead_numeric_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='numreg identifier id'>numreg</span> <span class='assign token'>=</span> <span class='regexp val'>/\d/</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span> <span class='or or kw'>or</span> <span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_NEGATIVE constant id'>ATOM_NUMERIC_NEGATIVE</span> <span class='and and kw'>and</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='integer val'>0</span><span class='semicolon token'>;</span> <span class='num identifier id'>num</span> <span class='assign token'>=</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='false false kw'>false</span><span class='semicolon token'>;</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='true true kw'>true</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='lt op'>&lt;</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='rparen token'>)</span>
              <span class='comment val'># EOL</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_NUMERIC_POINT constant id'>ATOM_NUMERIC_POINT</span><span class='rparen token'>)</span>
              <span class='comment val'># found point</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span>
                <span class='comment val'># Rewind and surrender</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='point_found identifier id'>point_found</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='end end kw'>end</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='numreg identifier id'>numreg</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># found more numerics, append to token</span>
              <span class='num identifier id'>num</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># found non-numeric</span>
              <span class='break break kw'>break</span>
            <span class='end end kw'>end</span> <span class='comment val'>#if: character match</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lparen token'>(</span><span class='lparen token'>(</span><span class='point_found identifier id'>point_found</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_f identifier id'>to_f</span> <span class='colon op'>:</span> <span class='num identifier id'>num</span><span class='dot token'>.</span><span class='to_i identifier id'>to_i</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span> <span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects boolean literals at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='true true kw'>true</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_TRUE constant id'>ATOM_BOOLEAN_TRUE</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='comma token'>,</span> <span class='false false kw'>false</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_BOOLEAN_FALSE constant id'>ATOM_BOOLEAN_FALSE</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects comparison operators at the given index in the given string query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>3</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>3</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span>  
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>2</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>2</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rbrack token'>]</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='COMPARISON_OPERATORS constant id'>COMPARISON_OPERATORS</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='rparen token'>)</span><span class='rparen token'>)</span> 
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a selection query at the given index in the given string query.</span>
      <span class='comment val'># A selection query may be composed of an optional root flag followed by one or more</span>
      <span class='comment val'># path components, read using read_ahead_path_component.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span> <span class='orop op'>||</span> <span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:use_root</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:path_components</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrace token'>}</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span>
          
          <span class='comment val'># Set root flag if found</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_ROOT constant id'>ATOM_PATH_ROOT</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='neq op'>!=</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Found unexpected character '&quot;</span><span class='plus op'>+</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='plus op'>+</span><span class='string val'>&quot;', expected ATOM_PATH_DELIMITER&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: root character not followed by query</span>
            <span class='comment val'># Exception dealt with, now set root flag and wind ahead</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:use_root</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: root query</span>
          
          <span class='comment val'># Now read in the path components</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='query_token identifier id'>query_token</span><span class='lbrack token'>[</span><span class='symbol val'>:path_components</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query_token identifier id'>query_token</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>        
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a path component at the given index in the given string query.</span>
      <span class='comment val'># A path component is composed of one or more path delimiters follows by a key or property name</span>
      <span class='comment val'># and an optional set of filter queries, read ahead using read_ahead_filter_query.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_path_component identifier id'>read_ahead_path_component</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span>
          <span class='comment val'># Set up the blank path component</span>
          <span class='path_component identifier id'>path_component</span> <span class='assign token'>=</span> <span class='lbrace token'>{</span><span class='symbol val'>:key</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:property</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='nil nil kw'>nil</span><span class='comma token'>,</span> <span class='symbol val'>:recursive</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='false false kw'>false</span><span class='comma token'>,</span> <span class='symbol val'>:filter_queries</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span><span class='rbrace token'>}</span>
          <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># 1. Handle recursive</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:recursive</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: recursive</span>
          
          <span class='comment val'># 2. Wildcards</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span><span class='rparen token'>)</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='ATOM_PATH_WILDCARD constant id'>ATOM_PATH_WILDCARD</span>
            <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>          
          <span class='else else kw'>else</span>
          <span class='comment val'># 3. Identify key type</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PROPERTY_IDENTIFIER constant id'>ATOM_PROPERTY_IDENTIFIER</span><span class='rparen token'>)</span>
              <span class='using_property identifier id'>using_property</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_PATH_DELIMITER constant id'>ATOM_PATH_DELIMITER</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='string val'>&quot;Too many ATOM_PATH_DELIMITER in a row - maximum allowed is two.&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#if: property identifier found or too many slashes</span>
            
            <span class='comment val'># 4. Read key or property name</span>
            <span class='keyname_result identifier id'>keyname_result</span> <span class='assign token'>=</span> <span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='dot token'>.</span><span class='nil? fid id'>nil?</span> <span class='and and kw'>and</span> <span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                    <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                    <span class='dstring node'>&quot;Unexpected character #{query[j,1]}, expected TOKEN_PROPERTY&quot;</span>
                    <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='keyname_result identifier id'>keyname_result</span><span class='rparen token'>)</span>
              <span class='comment val'># stash found key</span>
              <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='lparen token'>(</span><span class='using_property identifier id'>using_property</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='symbol val'>:property</span> <span class='colon op'>:</span> <span class='symbol val'>:key</span><span class='rbrack token'>]</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='keyname_result identifier id'>keyname_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='end end kw'>end</span><span class='comment val'>#if:keyname or propertyname found</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: wildcard/property/key</span>
          
          <span class='comment val'># 5. Read filter queries</span>
          <span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='filter_query_result identifier id'>filter_query_result</span> <span class='assign token'>=</span> <span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='path_component identifier id'>path_component</span><span class='lbrack token'>[</span><span class='symbol val'>:filter_queries</span><span class='rbrack token'>]</span> <span class='lshft op'>&lt;&lt;</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='filter_query_result identifier id'>filter_query_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span>
          
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='path_component identifier id'>path_component</span><span class='rbrack token'>]</span>
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a filter query at the given index in the given string query.</span>
      <span class='comment val'># A filter query is a selection or assertion query wrapped in the ATOM_FILTER_QUERY_START and</span>
      <span class='comment val'># ATOM_FILTER_QUERY_END character atoms and is parsed as an independent using parse_query. </span>
      <span class='comment val'># </span>
      <span class='comment val'># This has the benefit of putting filter queries into the pre-parsed query cache.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_filter_query identifier id'>read_ahead_filter_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='depth identifier id'>depth</span> <span class='assign token'>=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
          
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='j identifier id'>j</span> <span class='gt op'>&gt;</span> <span class='query identifier id'>query</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rparen token'>)</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected EOL, expected ATOM_FILTER_QUERY_END. (Bracket depth: #{depth})&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_START constant id'>ATOM_FILTER_QUERY_START</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_FILTER_QUERY_END constant id'>ATOM_FILTER_QUERY_END</span><span class='rparen token'>)</span>
              <span class='depth identifier id'>depth</span> <span class='opasgn op'>-=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span><span class='semicolon token'>;</span>
              <span class='break break kw'>break</span> <span class='if if_mod kw'>if</span><span class='lparen token'>(</span><span class='depth identifier id'>depth</span> <span class='eq op'>==</span> <span class='integer val'>0</span><span class='rparen token'>)</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span><span class='semicolon token'>;</span> 
            <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='string_result identifier id'>string_result</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># String literals - we use the internal string reader as it will ignore any square brackets within the quote marks.</span>
              <span class='comment val'># The resume index is used to bulk-append the characters to the query token</span>
              <span class='query_token identifier id'>query_token</span> <span class='opasgn op'>+=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='dot2 op'>..</span><span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='minus op'>-</span><span class='integer val'>1</span><span class='rbrack token'>]</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='string_result identifier id'>string_result</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
            <span class='else else kw'>else</span>
              <span class='comment val'># Regular append</span>
              <span class='query_token identifier id'>query_token</span> <span class='lshft op'>&lt;&lt;</span> <span class='ch identifier id'>ch</span>
              <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
            <span class='end end kw'>end</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: depth</span>
          
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span> <span class='comment val'># query token does not include final closing bracket</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='parse_query identifier id'>parse_query</span><span class='lparen token'>(</span><span class='query_token identifier id'>query_token</span><span class='rparen token'>)</span><span class='rbrack token'>]</span>
          <span class='else else kw'>else</span>
           <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                 <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                 <span class='string val'>&quot;Found unexpected ATOM_FILTER_QUERY_END, expected TOKEN_SELECTION_QUERY or TOKEN_ASSERTION_QUERY. Looked like those brackets were empty - make sure they have a query in them.&quot;</span>
                 <span class='rparen token'>)</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: token length</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Detects a set literal at the given index in the given string query.</span>
      <span class='comment val'># A set literal is composed of one or more string literals, numeric literals, boolean literals</span>
      <span class='comment val'># or selection queries wrapped in the ATOM_SET_START and ATOM_SET_END character atoms. </span>
      <span class='comment val'># </span>
      <span class='comment val'># Within the set, selection queries are parsed and cached using parse_query. The ATOM_SET_ARRAY_DELIMITER</span>
      <span class='comment val'># is used to separate values. Alternatively the ATOM_SET_RANGE_DELIMITER may be used to create a macro or</span>
      <span class='comment val'># &quot;range&quot; set containing a numeric or alphabetic range. The two types of delimiters may not be mixed.</span>
      <span class='comment val'>#</span>
      <span class='comment val'># @param [Numeric] i The index at which to detect the token</span>
      <span class='comment val'># @param [String] query The string query</span>
      <span class='comment val'># @return [Array, nil] An array in the form [resumeIndex, foundToken], or nil if no token was found.</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
        <span class='ch identifier id'>ch</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span>
        <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='ch identifier id'>ch</span> <span class='eq op'>==</span> <span class='ATOM_SET_START constant id'>ATOM_SET_START</span><span class='rparen token'>)</span>
          <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='i identifier id'>i</span><span class='plus op'>+</span><span class='integer val'>1</span>
          <span class='tokens identifier id'>tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='rbrack token'>]</span>
          <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='false false kw'>false</span>
          
          <span class='comment val'># Empty sets</span>
          <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
             <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='plus op'>+</span><span class='integer val'>1</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span>
          <span class='end end kw'>end</span><span class='comment val'>#if: empty set</span>
          
          <span class='comment val'># Populated sets - do the while/read_ahead thing</span>
          <span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
          <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='read_result identifier id'>read_result</span> <span class='assign token'>=</span> <span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
            <span class='t_type identifier id'>t_type</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token_type</span><span class='rbrack token'>]</span>
            <span class='allowed_tokens identifier id'>allowed_tokens</span> <span class='assign token'>=</span> <span class='lbrack token'>[</span><span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span><span class='comma token'>,</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span><span class='rbrack token'>]</span>
            <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='allowed_tokens identifier id'>allowed_tokens</span><span class='dot token'>.</span><span class='include? fid id'>include?</span><span class='lparen token'>(</span><span class='t_type identifier id'>t_type</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
              <span class='comment val'># wind ahead</span>
              <span class='j identifier id'>j</span> <span class='assign token'>=</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:resume_at</span><span class='rbrack token'>]</span>
              <span class='comment val'># stash in set</span>
              <span class='tokens identifier id'>tokens</span> <span class='lshft op'>&lt;&lt;</span> <span class='read_result identifier id'>read_result</span><span class='lbrack token'>[</span><span class='symbol val'>:token</span><span class='rbrack token'>]</span>
              <span class='comment val'># find delimiter or closing bracket</span>
              <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_ARRAY_DELIMITER constant id'>ATOM_SET_ARRAY_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found array delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># Mixed delimiters, throw a wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_RANGE_DELIMITER, already used ATOM_SET_ARRAY_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used range delimiter when array delimiter used</span>
                <span class='used_array_delimiter identifier id'>used_array_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='rparen token'>)</span>
                <span class='comment val'># found range delimiter</span>
                <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='used_array_delimiter identifier id'>used_array_delimiter</span><span class='rparen token'>)</span>
                  <span class='comment val'># mixed delimiters, throw wobbler</span>
                  <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                         <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                         <span class='string val'>&quot;Found unexpected ATOM_SET_ARRAY_DELIMITER, already used ATOM_SET_RANGE_DELIMITER and delimiters may not be mixed.&quot;</span>
                         <span class='rparen token'>)</span>
                <span class='end end kw'>end</span><span class='comment val'>#if: used array delimiter when range delimiter used</span>
                <span class='used_range_delimiter identifier id'>used_range_delimiter</span> <span class='assign token'>=</span> <span class='true true kw'>true</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='ATOM_SET_RANGE_DELIMITER constant id'>ATOM_SET_RANGE_DELIMITER</span><span class='dot token'>.</span><span class='length identifier id'>length</span>
              <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='integer val'>1</span><span class='rbrack token'>]</span> <span class='eq op'>==</span> <span class='ATOM_SET_END constant id'>ATOM_SET_END</span><span class='rparen token'>)</span>
                <span class='comment val'># end set</span>
                <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
                <span class='break break kw'>break</span>
              <span class='else else kw'>else</span>
                <span class='comment val'># dunno, throw toys out the pram</span>
                <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                       <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                       <span class='dstring node'>&quot;Found unexpected character #{query[j,1]}, expected ATOM_SET_ARRAY_DELIMITER, ATOM_SET_RANGE_DELIMITER or ATOM_SET_END&quot;</span>
                       <span class='rparen token'>)</span>
              <span class='end end kw'>end</span><span class='comment val'>#if: character match</span>
            <span class='else else kw'>else</span>
              <span class='raise identifier id'>raise</span> <span class='Spah constant id'>Spah</span><span class='colon2 op'>::</span><span class='SpahQL constant id'>SpahQL</span><span class='colon2 op'>::</span><span class='Errors constant id'>Errors</span><span class='colon2 op'>::</span><span class='CompilerError constant id'>CompilerError</span><span class='dot token'>.</span><span class='new identifier id'>new</span><span class='lparen token'>(</span>
                     <span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='comma token'>,</span> 
                     <span class='dstring node'>&quot;Found unexpected #{t_type}, expected one of #{allowed_tokens.join(&quot;,&quot;)}&quot;</span>
                     <span class='rparen token'>)</span>
            <span class='end end kw'>end</span><span class='comment val'>#allowed tokens</span>
          <span class='end end kw'>end</span><span class='comment val'>#while: read tokens</span>

          <span class='comment val'># Return match</span>
          <span class='return return kw'>return</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='lbrace token'>{</span><span class='symbol val'>:type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span><span class='comma token'>,</span> <span class='symbol val'>:values</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='tokens identifier id'>tokens</span><span class='comma token'>,</span> <span class='symbol val'>:is_range</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='used_range_delimiter identifier id'>used_range_delimiter</span><span class='rbrace token'>}</span><span class='rbrack token'>]</span><span class='semicolon token'>;</span>
          
        <span class='end end kw'>end</span><span class='comment val'>#if: token match</span>
        <span class='comment val'># No match</span>
        <span class='return return kw'>return</span> <span class='nil nil kw'>nil</span>
      <span class='end end kw'>end</span>
      
      <span class='comment val'># Reads ahead for alphanumeric, underscore and hyphen characters</span>
      <span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_inline_variable_reference identifier id'>read_ahead_inline_variable_reference</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
         <span class='valid identifier id'>valid</span> <span class='assign token'>=</span> <span class='regexp val'>/[\w\d_-]/</span><span class='semicolon token'>;</span> <span class='j identifier id'>j</span><span class='assign token'>=</span><span class='i identifier id'>i</span><span class='semicolon token'>;</span> <span class='token identifier id'>token</span> <span class='assign token'>=</span> <span class='string val'>&quot;&quot;</span><span class='semicolon token'>;</span>
         <span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
         <span class='while while kw'>while</span><span class='lparen token'>(</span><span class='m identifier id'>m</span> <span class='assign token'>=</span> <span class='query identifier id'>query</span><span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='dot token'>.</span><span class='match identifier id'>match</span><span class='lparen token'>(</span><span class='valid identifier id'>valid</span><span class='rparen token'>)</span><span class='rparen token'>)</span> <span class='do do kw'>do</span>
           <span class='token identifier id'>token</span> <span class='opasgn op'>+=</span> <span class='m identifier id'>m</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span>
           <span class='j identifier id'>j</span> <span class='opasgn op'>+=</span> <span class='integer val'>1</span>
         <span class='end end kw'>end</span><span class='comment val'>#while</span>
         <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='token identifier id'>token</span><span class='dot token'>.</span><span class='length identifier id'>length</span> <span class='gt op'>&gt;</span> <span class='integer val'>0</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrack token'>[</span><span class='j identifier id'>j</span><span class='comma token'>,</span> <span class='token identifier id'>token</span><span class='rbrack token'>]</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span><span class='semicolon token'>;</span>
      <span class='end end kw'>end</span>
      
    <span class='end end kw'>end</span>
  <span class='end end kw'>end</span>
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
      <div class="method_details ">
  <p class="signature " id="read_ahead_token-class_method">
  
    + (<tt>Hash</tt><sup>?</sup>) <strong>read_ahead_token</strong>(i, query) 
  

  
</p><div class="docstring">
  <div class="discussion">
    <p>
Detects a token of any type and returns the resume index and the found
token, along with the type of token encountered.
</p>


  </div>
</div>
<div class="tags">
  <h3>Parameters:</h3>
<ul class="param">
  
    <li>
      
        <span class='type'>(<tt>Numeric</tt>)</span>
      
      
        <span class='name'>i</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The index at which to detect the token
</p>
</div>
      
    </li>
  
    <li>
      
        <span class='type'>(<tt>String</tt>)</span>
      
      
        <span class='name'>query</span>
      
      
      
        &mdash;
        <div class='inline'><p>
The string query
</p>
</div>
      
    </li>
  
</ul>
<h3>Returns:</h3>
<ul class="return">
  
    <li>
      
        <span class='type'>(<tt>Hash</tt>, <tt>nil</tt>)</span>
      
      
      
      
        &mdash;
        <div class='inline'><p>
A hash with keys :resume_at, :token, :token_type, or nil.
</p>
</div>
      
    </li>
  
</ul>

</div><table class="source_code">
  <tr>
    <td>
      <pre class="lines">


163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180</pre>
    </td>
    <td>
      <pre class="code"><span class="info file"># File 'lib/spahql/query_parser.rb', line 163</span>

<span class='def def kw'>def</span> <span class='self self kw'>self</span><span class='dot token'>.</span><span class='read_ahead_token identifier id'>read_ahead_token</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span>
  <span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='nil nil kw'>nil</span>
  <span class='if if kw'>if</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_comparison_operator identifier id'>read_ahead_comparison_operator</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_COMPARISON_OPERATOR constant id'>TOKEN_COMPARISON_OPERATOR</span> 
  <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_string_literal identifier id'>read_ahead_string_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_STRING_LITERAL constant id'>TOKEN_STRING_LITERAL</span>
  <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_numeric_literal identifier id'>read_ahead_numeric_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_NUMERIC_LITERAL constant id'>TOKEN_NUMERIC_LITERAL</span> 
  <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_boolean_literal identifier id'>read_ahead_boolean_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_BOOLEAN_LITERAL constant id'>TOKEN_BOOLEAN_LITERAL</span>
  <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_set_literal identifier id'>read_ahead_set_literal</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_SET_LITERAL constant id'>TOKEN_SET_LITERAL</span>
  <span class='elsif elsif kw'>elsif</span><span class='lparen token'>(</span><span class='r identifier id'>r</span> <span class='assign token'>=</span> <span class='read_ahead_selection_query identifier id'>read_ahead_selection_query</span><span class='lparen token'>(</span><span class='i identifier id'>i</span><span class='comma token'>,</span> <span class='query identifier id'>query</span><span class='rparen token'>)</span><span class='rparen token'>)</span>
    <span class='type identifier id'>type</span> <span class='assign token'>=</span> <span class='TOKEN_SELECTION_QUERY constant id'>TOKEN_SELECTION_QUERY</span> 
  <span class='end end kw'>end</span>
  
  <span class='return return kw'>return</span> <span class='lparen token'>(</span><span class='r identifier id'>r</span><span class='rparen token'>)</span><span class='question op'>?</span> <span class='lbrace token'>{</span><span class='symbol val'>:resume_at</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='integer val'>0</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:token</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='r identifier id'>r</span><span class='lbrack token'>[</span><span class='integer val'>1</span><span class='rbrack token'>]</span><span class='comma token'>,</span> <span class='symbol val'>:token_type</span> <span class='assign token'>=</span><span class='gt op'>&gt;</span> <span class='type identifier id'>type</span><span class='rbrace token'>}</span> <span class='colon op'>:</span> <span class='nil nil kw'>nil</span>        
<span class='end end kw'>end</span>
</pre>
    </td>
  </tr>
</table>
</div>
    
  </div>

</div>
    
    <div id="footer">
  Generated on Mon Jun 13 21:23:46 2011 by 
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.6.8 (ruby-1.8.7).
</div>

  </body>
</html>